
C:\Users\Khiem\Atollic\TrueSTUDIO\ARM_workspace_7.0\cppPrintf_v0_2\Debug\cppPrintf_v0_2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000258c  080001ac  080001ac  000101ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000144  08002738  08002738  00012738  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800287c  0800287c  0001287c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08002880  08002880  00012880  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000008  20000000  08002884  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00020008  2**0
                  CONTENTS
  7 .bss          00000130  20000008  20000008  00020008  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  20000138  20000138  00020008  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020008  2**0
                  CONTENTS, READONLY
 10 .debug_line   0000489c  00000000  00000000  00020038  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0000c475  00000000  00000000  000248d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000236b  00000000  00000000  00030d49  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000007b0  00000000  00000000  000330b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000910  00000000  00000000  00033868  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00004f5a  00000000  00000000  00034178  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000308b  00000000  00000000  000390d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  0003c15d  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000013e0  00000000  00000000  0003c1dc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001ac <__do_global_dtors_aux>:
 80001ac:	b510      	push	{r4, lr}
 80001ae:	4c05      	ldr	r4, [pc, #20]	; (80001c4 <__do_global_dtors_aux+0x18>)
 80001b0:	7823      	ldrb	r3, [r4, #0]
 80001b2:	b933      	cbnz	r3, 80001c2 <__do_global_dtors_aux+0x16>
 80001b4:	4b04      	ldr	r3, [pc, #16]	; (80001c8 <__do_global_dtors_aux+0x1c>)
 80001b6:	b113      	cbz	r3, 80001be <__do_global_dtors_aux+0x12>
 80001b8:	4804      	ldr	r0, [pc, #16]	; (80001cc <__do_global_dtors_aux+0x20>)
 80001ba:	f3af 8000 	nop.w
 80001be:	2301      	movs	r3, #1
 80001c0:	7023      	strb	r3, [r4, #0]
 80001c2:	bd10      	pop	{r4, pc}
 80001c4:	20000008 	.word	0x20000008
 80001c8:	00000000 	.word	0x00000000
 80001cc:	08002720 	.word	0x08002720

080001d0 <frame_dummy>:
 80001d0:	b508      	push	{r3, lr}
 80001d2:	4b03      	ldr	r3, [pc, #12]	; (80001e0 <frame_dummy+0x10>)
 80001d4:	b11b      	cbz	r3, 80001de <frame_dummy+0xe>
 80001d6:	4903      	ldr	r1, [pc, #12]	; (80001e4 <frame_dummy+0x14>)
 80001d8:	4803      	ldr	r0, [pc, #12]	; (80001e8 <frame_dummy+0x18>)
 80001da:	f3af 8000 	nop.w
 80001de:	bd08      	pop	{r3, pc}
 80001e0:	00000000 	.word	0x00000000
 80001e4:	2000000c 	.word	0x2000000c
 80001e8:	08002720 	.word	0x08002720

080001ec <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80001ec:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000224 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80001f0:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80001f2:	e003      	b.n	80001fc <LoopCopyDataInit>

080001f4 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80001f4:	4b0c      	ldr	r3, [pc, #48]	; (8000228 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80001f6:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80001f8:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80001fa:	3104      	adds	r1, #4

080001fc <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80001fc:	480b      	ldr	r0, [pc, #44]	; (800022c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80001fe:	4b0c      	ldr	r3, [pc, #48]	; (8000230 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8000200:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8000202:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000204:	d3f6      	bcc.n	80001f4 <CopyDataInit>
  ldr  r2, =_sbss
 8000206:	4a0b      	ldr	r2, [pc, #44]	; (8000234 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8000208:	e002      	b.n	8000210 <LoopFillZerobss>

0800020a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800020a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800020c:	f842 3b04 	str.w	r3, [r2], #4

08000210 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000210:	4b09      	ldr	r3, [pc, #36]	; (8000238 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8000212:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000214:	d3f9      	bcc.n	800020a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8000216:	f002 f9f1 	bl	80025fc <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800021a:	f002 fa5b 	bl	80026d4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800021e:	f002 f959 	bl	80024d4 <main>
  bx  lr    
 8000222:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8000224:	20030000 	.word	0x20030000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8000228:	08002884 	.word	0x08002884
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800022c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000230:	20000008 	.word	0x20000008
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8000234:	20000008 	.word	0x20000008
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000238:	20000138 	.word	0x20000138

0800023c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800023c:	e7fe      	b.n	800023c <ADC_IRQHandler>
	...

08000240 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000240:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000242:	4b08      	ldr	r3, [pc, #32]	; (8000264 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000244:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000246:	6818      	ldr	r0, [r3, #0]
 8000248:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800024c:	fbb0 f0f3 	udiv	r0, r0, r3
 8000250:	f000 f8a0 	bl	8000394 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8000254:	2200      	movs	r2, #0
 8000256:	4621      	mov	r1, r4
 8000258:	f04f 30ff 	mov.w	r0, #4294967295
 800025c:	f000 f856 	bl	800030c <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000260:	2000      	movs	r0, #0
 8000262:	bd10      	pop	{r4, pc}
 8000264:	20000004 	.word	0x20000004

08000268 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000268:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800026a:	4b0b      	ldr	r3, [pc, #44]	; (8000298 <HAL_Init+0x30>)
 800026c:	681a      	ldr	r2, [r3, #0]
 800026e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000272:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8000274:	681a      	ldr	r2, [r3, #0]
 8000276:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800027a:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800027c:	681a      	ldr	r2, [r3, #0]
 800027e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000282:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000284:	2003      	movs	r0, #3
 8000286:	f000 f825 	bl	80002d4 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800028a:	2000      	movs	r0, #0
 800028c:	f7ff ffd8 	bl	8000240 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8000290:	f002 f974 	bl	800257c <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8000294:	2000      	movs	r0, #0
 8000296:	bd08      	pop	{r3, pc}
 8000298:	40023c00 	.word	0x40023c00

0800029c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 800029c:	4a02      	ldr	r2, [pc, #8]	; (80002a8 <HAL_IncTick+0xc>)
 800029e:	6813      	ldr	r3, [r2, #0]
 80002a0:	3301      	adds	r3, #1
 80002a2:	6013      	str	r3, [r2, #0]
 80002a4:	4770      	bx	lr
 80002a6:	bf00      	nop
 80002a8:	20000030 	.word	0x20000030

080002ac <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80002ac:	4b01      	ldr	r3, [pc, #4]	; (80002b4 <HAL_GetTick+0x8>)
 80002ae:	6818      	ldr	r0, [r3, #0]
}
 80002b0:	4770      	bx	lr
 80002b2:	bf00      	nop
 80002b4:	20000030 	.word	0x20000030

080002b8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 80002b8:	b513      	push	{r0, r1, r4, lr}
 80002ba:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 80002bc:	f7ff fff6 	bl	80002ac <HAL_GetTick>
 80002c0:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 80002c2:	f7ff fff3 	bl	80002ac <HAL_GetTick>
 80002c6:	9b01      	ldr	r3, [sp, #4]
 80002c8:	1b00      	subs	r0, r0, r4
 80002ca:	4298      	cmp	r0, r3
 80002cc:	d3f9      	bcc.n	80002c2 <HAL_Delay+0xa>
  {
  }
}
 80002ce:	b002      	add	sp, #8
 80002d0:	bd10      	pop	{r4, pc}
	...

080002d4 <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80002d4:	1ec3      	subs	r3, r0, #3
 80002d6:	2b04      	cmp	r3, #4
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80002d8:	b510      	push	{r4, lr}
 80002da:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80002dc:	d903      	bls.n	80002e6 <HAL_NVIC_SetPriorityGrouping+0x12>
 80002de:	21a4      	movs	r1, #164	; 0xa4
 80002e0:	4808      	ldr	r0, [pc, #32]	; (8000304 <HAL_NVIC_SetPriorityGrouping+0x30>)
 80002e2:	f002 f906 	bl	80024f2 <assert_failed>
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80002e6:	4a08      	ldr	r2, [pc, #32]	; (8000308 <HAL_NVIC_SetPriorityGrouping+0x34>)
 80002e8:	68d1      	ldr	r1, [r2, #12]
 80002ea:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80002ee:	400b      	ands	r3, r1
 80002f0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80002f4:	0224      	lsls	r4, r4, #8
 80002f6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80002fa:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
 80002fe:	4323      	orrs	r3, r4
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000300:	60d3      	str	r3, [r2, #12]
 8000302:	bd10      	pop	{r4, pc}
 8000304:	08002738 	.word	0x08002738
 8000308:	e000ed00 	.word	0xe000ed00

0800030c <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
  uint32_t prioritygroup = 0x00U;
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 800030c:	2a0f      	cmp	r2, #15
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800030e:	b570      	push	{r4, r5, r6, lr}
 8000310:	4605      	mov	r5, r0
 8000312:	460e      	mov	r6, r1
 8000314:	4614      	mov	r4, r2
  uint32_t prioritygroup = 0x00U;
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 8000316:	d903      	bls.n	8000320 <HAL_NVIC_SetPriority+0x14>
 8000318:	21bc      	movs	r1, #188	; 0xbc
 800031a:	481b      	ldr	r0, [pc, #108]	; (8000388 <HAL_NVIC_SetPriority+0x7c>)
 800031c:	f002 f8e9 	bl	80024f2 <assert_failed>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8000320:	2e0f      	cmp	r6, #15
 8000322:	d903      	bls.n	800032c <HAL_NVIC_SetPriority+0x20>
 8000324:	21bd      	movs	r1, #189	; 0xbd
 8000326:	4818      	ldr	r0, [pc, #96]	; (8000388 <HAL_NVIC_SetPriority+0x7c>)
 8000328:	f002 f8e3 	bl	80024f2 <assert_failed>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800032c:	4b17      	ldr	r3, [pc, #92]	; (800038c <HAL_NVIC_SetPriority+0x80>)
 800032e:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000330:	f3c3 2302 	ubfx	r3, r3, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000334:	f1c3 0207 	rsb	r2, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000338:	1d19      	adds	r1, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800033a:	2a04      	cmp	r2, #4
 800033c:	bf28      	it	cs
 800033e:	2204      	movcs	r2, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000340:	2906      	cmp	r1, #6

  return (
 8000342:	f04f 0101 	mov.w	r1, #1
 8000346:	fa01 f202 	lsl.w	r2, r1, r2
 800034a:	f102 32ff 	add.w	r2, r2, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800034e:	bf8c      	ite	hi
 8000350:	3b03      	subhi	r3, #3
 8000352:	2300      	movls	r3, #0

  return (
 8000354:	4032      	ands	r2, r6
 8000356:	409a      	lsls	r2, r3
 8000358:	fa01 f303 	lsl.w	r3, r1, r3
 800035c:	3b01      	subs	r3, #1
 800035e:	401c      	ands	r4, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000360:	2d00      	cmp	r5, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000362:	ea44 0402 	orr.w	r4, r4, r2
 8000366:	ea4f 1404 	mov.w	r4, r4, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800036a:	bfaf      	iteee	ge
 800036c:	f105 4560 	addge.w	r5, r5, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000370:	f005 050f 	andlt.w	r5, r5, #15
 8000374:	4b06      	ldrlt	r3, [pc, #24]	; (8000390 <HAL_NVIC_SetPriority+0x84>)
 8000376:	b2e4      	uxtblt	r4, r4
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000378:	bfa5      	ittet	ge
 800037a:	f505 4561 	addge.w	r5, r5, #57600	; 0xe100
 800037e:	b2e4      	uxtbge	r4, r4
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000380:	555c      	strblt	r4, [r3, r5]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000382:	f885 4300 	strbge.w	r4, [r5, #768]	; 0x300
 8000386:	bd70      	pop	{r4, r5, r6, pc}
 8000388:	08002738 	.word	0x08002738
 800038c:	e000ed00 	.word	0xe000ed00
 8000390:	e000ed14 	.word	0xe000ed14

08000394 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000394:	3801      	subs	r0, #1
 8000396:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800039a:	d20a      	bcs.n	80003b2 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800039c:	4b06      	ldr	r3, [pc, #24]	; (80003b8 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800039e:	4a07      	ldr	r2, [pc, #28]	; (80003bc <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80003a0:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003a2:	21f0      	movs	r1, #240	; 0xf0
 80003a4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003a8:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003aa:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003ac:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003ae:	601a      	str	r2, [r3, #0]
 80003b0:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 80003b2:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80003b4:	4770      	bx	lr
 80003b6:	bf00      	nop
 80003b8:	e000e010 	.word	0xe000e010
 80003bc:	e000ed00 	.word	0xe000ed00

080003c0 <HAL_SYSTICK_CLKSourceConfig>:
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
 80003c0:	2804      	cmp	r0, #4
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 80003c2:	b510      	push	{r4, lr}
 80003c4:	4c08      	ldr	r4, [pc, #32]	; (80003e8 <HAL_SYSTICK_CLKSourceConfig+0x28>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
 80003c6:	d009      	beq.n	80003dc <HAL_SYSTICK_CLKSourceConfig+0x1c>
 80003c8:	b120      	cbz	r0, 80003d4 <HAL_SYSTICK_CLKSourceConfig+0x14>
 80003ca:	f240 11b3 	movw	r1, #435	; 0x1b3
 80003ce:	4807      	ldr	r0, [pc, #28]	; (80003ec <HAL_SYSTICK_CLKSourceConfig+0x2c>)
 80003d0:	f002 f88f 	bl	80024f2 <assert_failed>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 80003d4:	6823      	ldr	r3, [r4, #0]
 80003d6:	f023 0304 	bic.w	r3, r3, #4
 80003da:	e002      	b.n	80003e2 <HAL_SYSTICK_CLKSourceConfig+0x22>
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80003dc:	6823      	ldr	r3, [r4, #0]
 80003de:	f043 0304 	orr.w	r3, r3, #4
 80003e2:	6023      	str	r3, [r4, #0]
 80003e4:	bd10      	pop	{r4, pc}
 80003e6:	bf00      	nop
 80003e8:	e000e010 	.word	0xe000e010
 80003ec:	08002738 	.word	0x08002738

080003f0 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 80003f0:	4770      	bx	lr

080003f2 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 80003f2:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 80003f4:	f7ff fffc 	bl	80003f0 <HAL_SYSTICK_Callback>
 80003f8:	bd08      	pop	{r3, pc}
	...

080003fc <HAL_GPIO_Init>:
  uint32_t ioposition = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t temp = 0x00U;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 80003fc:	4ba3      	ldr	r3, [pc, #652]	; (800068c <HAL_GPIO_Init+0x290>)
 80003fe:	4298      	cmp	r0, r3
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000400:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000404:	4604      	mov	r4, r0
 8000406:	460d      	mov	r5, r1
  uint32_t ioposition = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t temp = 0x00U;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8000408:	d02b      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 800040a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800040e:	4298      	cmp	r0, r3
 8000410:	d027      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 8000412:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000416:	4298      	cmp	r0, r3
 8000418:	d023      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 800041a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800041e:	4298      	cmp	r0, r3
 8000420:	d01f      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 8000422:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000426:	4298      	cmp	r0, r3
 8000428:	d01b      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 800042a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800042e:	4298      	cmp	r0, r3
 8000430:	d017      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 8000432:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000436:	4298      	cmp	r0, r3
 8000438:	d013      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 800043a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800043e:	4298      	cmp	r0, r3
 8000440:	d00f      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 8000442:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000446:	4298      	cmp	r0, r3
 8000448:	d00b      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 800044a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800044e:	4298      	cmp	r0, r3
 8000450:	d007      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 8000452:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000456:	4298      	cmp	r0, r3
 8000458:	d003      	beq.n	8000462 <HAL_GPIO_Init+0x66>
 800045a:	21c5      	movs	r1, #197	; 0xc5
 800045c:	488c      	ldr	r0, [pc, #560]	; (8000690 <HAL_GPIO_Init+0x294>)
 800045e:	f002 f848 	bl	80024f2 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 8000462:	882b      	ldrh	r3, [r5, #0]
 8000464:	b91b      	cbnz	r3, 800046e <HAL_GPIO_Init+0x72>
 8000466:	21c6      	movs	r1, #198	; 0xc6
 8000468:	4889      	ldr	r0, [pc, #548]	; (8000690 <HAL_GPIO_Init+0x294>)
 800046a:	f002 f842 	bl	80024f2 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 800046e:	686b      	ldr	r3, [r5, #4]
 8000470:	2b03      	cmp	r3, #3
 8000472:	d917      	bls.n	80004a4 <HAL_GPIO_Init+0xa8>
 8000474:	f1a3 0211 	sub.w	r2, r3, #17
 8000478:	2a01      	cmp	r2, #1
 800047a:	d913      	bls.n	80004a4 <HAL_GPIO_Init+0xa8>
 800047c:	4985      	ldr	r1, [pc, #532]	; (8000694 <HAL_GPIO_Init+0x298>)
 800047e:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
 8000482:	428a      	cmp	r2, r1
 8000484:	d00e      	beq.n	80004a4 <HAL_GPIO_Init+0xa8>
 8000486:	f501 1180 	add.w	r1, r1, #1048576	; 0x100000
 800048a:	428b      	cmp	r3, r1
 800048c:	d00a      	beq.n	80004a4 <HAL_GPIO_Init+0xa8>
 800048e:	f5a1 2170 	sub.w	r1, r1, #983040	; 0xf0000
 8000492:	428a      	cmp	r2, r1
 8000494:	d006      	beq.n	80004a4 <HAL_GPIO_Init+0xa8>
 8000496:	4a80      	ldr	r2, [pc, #512]	; (8000698 <HAL_GPIO_Init+0x29c>)
 8000498:	4293      	cmp	r3, r2
 800049a:	d003      	beq.n	80004a4 <HAL_GPIO_Init+0xa8>
 800049c:	21c7      	movs	r1, #199	; 0xc7
 800049e:	487c      	ldr	r0, [pc, #496]	; (8000690 <HAL_GPIO_Init+0x294>)
 80004a0:	f002 f827 	bl	80024f2 <assert_failed>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 80004a4:	68ab      	ldr	r3, [r5, #8]
 80004a6:	2b02      	cmp	r3, #2
 80004a8:	d903      	bls.n	80004b2 <HAL_GPIO_Init+0xb6>
 80004aa:	21c8      	movs	r1, #200	; 0xc8
 80004ac:	4878      	ldr	r0, [pc, #480]	; (8000690 <HAL_GPIO_Init+0x294>)
 80004ae:	f002 f820 	bl	80024f2 <assert_failed>
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80004b2:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 80006a0 <HAL_GPIO_Init+0x2a4>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80004b6:	2600      	movs	r6, #0
 80004b8:	46ca      	mov	sl, r9

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 80004ba:	2701      	movs	r7, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 80004bc:	682b      	ldr	r3, [r5, #0]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 80004be:	40b7      	lsls	r7, r6
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 80004c0:	ea37 0303 	bics.w	r3, r7, r3
 80004c4:	f040 80da 	bne.w	800067c <HAL_GPIO_Init+0x280>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80004c8:	686b      	ldr	r3, [r5, #4]
 80004ca:	f023 0310 	bic.w	r3, r3, #16
 80004ce:	2b02      	cmp	r3, #2
 80004d0:	d11a      	bne.n	8000508 <HAL_GPIO_Init+0x10c>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 80004d2:	692b      	ldr	r3, [r5, #16]
 80004d4:	2b0d      	cmp	r3, #13
 80004d6:	d905      	bls.n	80004e4 <HAL_GPIO_Init+0xe8>
 80004d8:	2b0f      	cmp	r3, #15
 80004da:	d003      	beq.n	80004e4 <HAL_GPIO_Init+0xe8>
 80004dc:	21d9      	movs	r1, #217	; 0xd9
 80004de:	486c      	ldr	r0, [pc, #432]	; (8000690 <HAL_GPIO_Init+0x294>)
 80004e0:	f002 f807 	bl	80024f2 <assert_failed>
 80004e4:	08f0      	lsrs	r0, r6, #3
 80004e6:	eb04 0080 	add.w	r0, r4, r0, lsl #2
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 80004ea:	f006 0e07 	and.w	lr, r6, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80004ee:	6a01      	ldr	r1, [r0, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 80004f0:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80004f4:	230f      	movs	r3, #15
 80004f6:	fa03 f30e 	lsl.w	r3, r3, lr
 80004fa:	ea21 0203 	bic.w	r2, r1, r3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 80004fe:	692b      	ldr	r3, [r5, #16]
 8000500:	fa03 f30e 	lsl.w	r3, r3, lr
 8000504:	4313      	orrs	r3, r2
        GPIOx->AFR[position >> 3U] = temp;
 8000506:	6203      	str	r3, [r0, #32]
 8000508:	ea4f 0846 	mov.w	r8, r6, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800050c:	f04f 0b03 	mov.w	fp, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000510:	6821      	ldr	r1, [r4, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000512:	686b      	ldr	r3, [r5, #4]
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000514:	fa0b fb08 	lsl.w	fp, fp, r8
 8000518:	ea6f 0b0b 	mvn.w	fp, fp
 800051c:	ea01 000b 	and.w	r0, r1, fp
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000520:	f003 0103 	and.w	r1, r3, #3
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000524:	f023 0310 	bic.w	r3, r3, #16
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000528:	fa01 f108 	lsl.w	r1, r1, r8
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800052c:	3b01      	subs	r3, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800052e:	4301      	orrs	r1, r0
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000530:	2b01      	cmp	r3, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8000532:	6021      	str	r1, [r4, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000534:	d817      	bhi.n	8000566 <HAL_GPIO_Init+0x16a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8000536:	68eb      	ldr	r3, [r5, #12]
 8000538:	2b03      	cmp	r3, #3
 800053a:	d903      	bls.n	8000544 <HAL_GPIO_Init+0x148>
 800053c:	21ec      	movs	r1, #236	; 0xec
 800053e:	4854      	ldr	r0, [pc, #336]	; (8000690 <HAL_GPIO_Init+0x294>)
 8000540:	f001 ffd7 	bl	80024f2 <assert_failed>
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000544:	68a3      	ldr	r3, [r4, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000546:	ea0b 0103 	and.w	r1, fp, r3
        temp |= (GPIO_Init->Speed << (position * 2U));
 800054a:	68eb      	ldr	r3, [r5, #12]
 800054c:	fa03 f308 	lsl.w	r3, r3, r8
 8000550:	430b      	orrs	r3, r1
        GPIOx->OSPEEDR = temp;
 8000552:	60a3      	str	r3, [r4, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000554:	6863      	ldr	r3, [r4, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000556:	ea23 0107 	bic.w	r1, r3, r7
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800055a:	686b      	ldr	r3, [r5, #4]
 800055c:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8000560:	40b3      	lsls	r3, r6
 8000562:	430b      	orrs	r3, r1
        GPIOx->OTYPER = temp;
 8000564:	6063      	str	r3, [r4, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000566:	68e3      	ldr	r3, [r4, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
      GPIOx->PUPDR = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000568:	6868      	ldr	r0, [r5, #4]
        GPIOx->OTYPER = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800056a:	ea0b 0b03 	and.w	fp, fp, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800056e:	68ab      	ldr	r3, [r5, #8]
 8000570:	fa03 f208 	lsl.w	r2, r3, r8
 8000574:	ea42 020b 	orr.w	r2, r2, fp
      GPIOx->PUPDR = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000578:	00c3      	lsls	r3, r0, #3

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
      temp |= ((GPIO_Init->Pull) << (position * 2U));
      GPIOx->PUPDR = temp;
 800057a:	60e2      	str	r2, [r4, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800057c:	d57e      	bpl.n	800067c <HAL_GPIO_Init+0x280>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800057e:	4a47      	ldr	r2, [pc, #284]	; (800069c <HAL_GPIO_Init+0x2a0>)
 8000580:	2300      	movs	r3, #0
 8000582:	9301      	str	r3, [sp, #4]
 8000584:	6c51      	ldr	r1, [r2, #68]	; 0x44
 8000586:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 800058a:	6451      	str	r1, [r2, #68]	; 0x44
 800058c:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800058e:	f026 0103 	bic.w	r1, r6, #3
 8000592:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8000596:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 800059a:	f501 319c 	add.w	r1, r1, #79872	; 0x13800
 800059e:	9201      	str	r2, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80005a0:	f006 0c03 	and.w	ip, r6, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80005a4:	9a01      	ldr	r2, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2U];
 80005a6:	f8d1 e008 	ldr.w	lr, [r1, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80005aa:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80005ae:	220f      	movs	r2, #15
 80005b0:	fa02 f20c 	lsl.w	r2, r2, ip
 80005b4:	ea2e 0e02 	bic.w	lr, lr, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80005b8:	4a34      	ldr	r2, [pc, #208]	; (800068c <HAL_GPIO_Init+0x290>)
 80005ba:	4294      	cmp	r4, r2
 80005bc:	d037      	beq.n	800062e <HAL_GPIO_Init+0x232>
 80005be:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80005c2:	f503 3301 	add.w	r3, r3, #132096	; 0x20400
 80005c6:	429c      	cmp	r4, r3
 80005c8:	d022      	beq.n	8000610 <HAL_GPIO_Init+0x214>
 80005ca:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80005ce:	429c      	cmp	r4, r3
 80005d0:	d020      	beq.n	8000614 <HAL_GPIO_Init+0x218>
 80005d2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80005d6:	429c      	cmp	r4, r3
 80005d8:	d01e      	beq.n	8000618 <HAL_GPIO_Init+0x21c>
 80005da:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80005de:	429c      	cmp	r4, r3
 80005e0:	d01c      	beq.n	800061c <HAL_GPIO_Init+0x220>
 80005e2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80005e6:	429c      	cmp	r4, r3
 80005e8:	d01a      	beq.n	8000620 <HAL_GPIO_Init+0x224>
 80005ea:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80005ee:	429c      	cmp	r4, r3
 80005f0:	d018      	beq.n	8000624 <HAL_GPIO_Init+0x228>
 80005f2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80005f6:	429c      	cmp	r4, r3
 80005f8:	d016      	beq.n	8000628 <HAL_GPIO_Init+0x22c>
 80005fa:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80005fe:	429c      	cmp	r4, r3
 8000600:	d014      	beq.n	800062c <HAL_GPIO_Init+0x230>
 8000602:	f502 5210 	add.w	r2, r2, #9216	; 0x2400
 8000606:	4294      	cmp	r4, r2
 8000608:	bf14      	ite	ne
 800060a:	230a      	movne	r3, #10
 800060c:	2309      	moveq	r3, #9
 800060e:	e00e      	b.n	800062e <HAL_GPIO_Init+0x232>
 8000610:	2301      	movs	r3, #1
 8000612:	e00c      	b.n	800062e <HAL_GPIO_Init+0x232>
 8000614:	2302      	movs	r3, #2
 8000616:	e00a      	b.n	800062e <HAL_GPIO_Init+0x232>
 8000618:	2303      	movs	r3, #3
 800061a:	e008      	b.n	800062e <HAL_GPIO_Init+0x232>
 800061c:	2304      	movs	r3, #4
 800061e:	e006      	b.n	800062e <HAL_GPIO_Init+0x232>
 8000620:	2305      	movs	r3, #5
 8000622:	e004      	b.n	800062e <HAL_GPIO_Init+0x232>
 8000624:	2306      	movs	r3, #6
 8000626:	e002      	b.n	800062e <HAL_GPIO_Init+0x232>
 8000628:	2307      	movs	r3, #7
 800062a:	e000      	b.n	800062e <HAL_GPIO_Init+0x232>
 800062c:	2308      	movs	r3, #8
 800062e:	fa03 f30c 	lsl.w	r3, r3, ip
 8000632:	ea43 030e 	orr.w	r3, r3, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000636:	608b      	str	r3, [r1, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000638:	f8d9 3000 	ldr.w	r3, [r9]
        temp &= ~((uint32_t)iocurrent);
 800063c:	43fa      	mvns	r2, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800063e:	03c1      	lsls	r1, r0, #15
        {
          temp |= iocurrent;
 8000640:	bf4c      	ite	mi
 8000642:	433b      	orrmi	r3, r7
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8000644:	4013      	andpl	r3, r2
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 8000646:	f8ca 3000 	str.w	r3, [sl]

        temp = EXTI->EMR;
 800064a:	f8da 3004 	ldr.w	r3, [sl, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800064e:	0381      	lsls	r1, r0, #14
        {
          temp |= iocurrent;
 8000650:	bf4c      	ite	mi
 8000652:	433b      	orrmi	r3, r7
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8000654:	4013      	andpl	r3, r2
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 8000656:	f8c9 3004 	str.w	r3, [r9, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800065a:	f8d9 3008 	ldr.w	r3, [r9, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800065e:	02c1      	lsls	r1, r0, #11
        {
          temp |= iocurrent;
 8000660:	bf4c      	ite	mi
 8000662:	433b      	orrmi	r3, r7
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8000664:	4013      	andpl	r3, r2
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8000666:	f8ca 3008 	str.w	r3, [sl, #8]

        temp = EXTI->FTSR;
 800066a:	f8da 300c 	ldr.w	r3, [sl, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800066e:	0281      	lsls	r1, r0, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8000670:	bf54      	ite	pl
 8000672:	ea02 0703 	andpl.w	r7, r2, r3
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8000676:	431f      	orrmi	r7, r3
        }
        EXTI->FTSR = temp;
 8000678:	f8c9 700c 	str.w	r7, [r9, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800067c:	3601      	adds	r6, #1
 800067e:	2e10      	cmp	r6, #16
 8000680:	f47f af1b 	bne.w	80004ba <HAL_GPIO_Init+0xbe>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8000684:	b003      	add	sp, #12
 8000686:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800068a:	bf00      	nop
 800068c:	40020000 	.word	0x40020000
 8000690:	08002773 	.word	0x08002773
 8000694:	10110000 	.word	0x10110000
 8000698:	10220000 	.word	0x10220000
 800069c:	40023800 	.word	0x40023800
 80006a0:	40013c00 	.word	0x40013c00

080006a4 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 80006a4:	6803      	ldr	r3, [r0, #0]
 80006a6:	2b0f      	cmp	r3, #15
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80006a8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80006ac:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 80006ae:	d903      	bls.n	80006b8 <HAL_RCC_OscConfig+0x14>
 80006b0:	21f5      	movs	r1, #245	; 0xf5
 80006b2:	48a4      	ldr	r0, [pc, #656]	; (8000944 <HAL_RCC_OscConfig+0x2a0>)
 80006b4:	f001 ff1d 	bl	80024f2 <assert_failed>
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80006b8:	6823      	ldr	r3, [r4, #0]
 80006ba:	07d8      	lsls	r0, r3, #31
 80006bc:	d403      	bmi.n	80006c6 <HAL_RCC_OscConfig+0x22>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80006be:	6823      	ldr	r3, [r4, #0]
 80006c0:	0799      	lsls	r1, r3, #30
 80006c2:	d456      	bmi.n	8000772 <HAL_RCC_OscConfig+0xce>
 80006c4:	e0b6      	b.n	8000834 <HAL_RCC_OscConfig+0x190>
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 80006c6:	6863      	ldr	r3, [r4, #4]
 80006c8:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
 80006cc:	d006      	beq.n	80006dc <HAL_RCC_OscConfig+0x38>
 80006ce:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80006d2:	d003      	beq.n	80006dc <HAL_RCC_OscConfig+0x38>
 80006d4:	21fa      	movs	r1, #250	; 0xfa
 80006d6:	489b      	ldr	r0, [pc, #620]	; (8000944 <HAL_RCC_OscConfig+0x2a0>)
 80006d8:	f001 ff0b 	bl	80024f2 <assert_failed>
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80006dc:	4b9a      	ldr	r3, [pc, #616]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
 80006de:	689a      	ldr	r2, [r3, #8]
 80006e0:	f002 020c 	and.w	r2, r2, #12
 80006e4:	2a04      	cmp	r2, #4
 80006e6:	d007      	beq.n	80006f8 <HAL_RCC_OscConfig+0x54>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80006e8:	689a      	ldr	r2, [r3, #8]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80006ea:	f002 020c 	and.w	r2, r2, #12
 80006ee:	2a08      	cmp	r2, #8
 80006f0:	d10b      	bne.n	800070a <HAL_RCC_OscConfig+0x66>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80006f2:	685b      	ldr	r3, [r3, #4]
 80006f4:	025a      	lsls	r2, r3, #9
 80006f6:	d508      	bpl.n	800070a <HAL_RCC_OscConfig+0x66>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80006f8:	4b93      	ldr	r3, [pc, #588]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
 80006fa:	681b      	ldr	r3, [r3, #0]
 80006fc:	039b      	lsls	r3, r3, #14
 80006fe:	d5de      	bpl.n	80006be <HAL_RCC_OscConfig+0x1a>
 8000700:	6863      	ldr	r3, [r4, #4]
 8000702:	2b00      	cmp	r3, #0
 8000704:	d1db      	bne.n	80006be <HAL_RCC_OscConfig+0x1a>
      {
        return HAL_ERROR;
 8000706:	2001      	movs	r0, #1
 8000708:	e1c5      	b.n	8000a96 <HAL_RCC_OscConfig+0x3f2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800070a:	6863      	ldr	r3, [r4, #4]
 800070c:	4d8e      	ldr	r5, [pc, #568]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
 800070e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000712:	d006      	beq.n	8000722 <HAL_RCC_OscConfig+0x7e>
 8000714:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8000718:	d108      	bne.n	800072c <HAL_RCC_OscConfig+0x88>
 800071a:	682b      	ldr	r3, [r5, #0]
 800071c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000720:	602b      	str	r3, [r5, #0]
 8000722:	682b      	ldr	r3, [r5, #0]
 8000724:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000728:	602b      	str	r3, [r5, #0]
 800072a:	e008      	b.n	800073e <HAL_RCC_OscConfig+0x9a>
 800072c:	682a      	ldr	r2, [r5, #0]
 800072e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000732:	602a      	str	r2, [r5, #0]
 8000734:	682a      	ldr	r2, [r5, #0]
 8000736:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800073a:	602a      	str	r2, [r5, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800073c:	b16b      	cbz	r3, 800075a <HAL_RCC_OscConfig+0xb6>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800073e:	f7ff fdb5 	bl	80002ac <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000742:	4d81      	ldr	r5, [pc, #516]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000744:	4606      	mov	r6, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000746:	682b      	ldr	r3, [r5, #0]
 8000748:	039f      	lsls	r7, r3, #14
 800074a:	d4b8      	bmi.n	80006be <HAL_RCC_OscConfig+0x1a>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800074c:	f7ff fdae 	bl	80002ac <HAL_GetTick>
 8000750:	1b80      	subs	r0, r0, r6
 8000752:	2864      	cmp	r0, #100	; 0x64
 8000754:	d9f7      	bls.n	8000746 <HAL_RCC_OscConfig+0xa2>
          {
            return HAL_TIMEOUT;
 8000756:	2003      	movs	r0, #3
 8000758:	e19d      	b.n	8000a96 <HAL_RCC_OscConfig+0x3f2>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800075a:	f7ff fda7 	bl	80002ac <HAL_GetTick>
 800075e:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000760:	682b      	ldr	r3, [r5, #0]
 8000762:	0398      	lsls	r0, r3, #14
 8000764:	d5ab      	bpl.n	80006be <HAL_RCC_OscConfig+0x1a>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000766:	f7ff fda1 	bl	80002ac <HAL_GetTick>
 800076a:	1b80      	subs	r0, r0, r6
 800076c:	2864      	cmp	r0, #100	; 0x64
 800076e:	d9f7      	bls.n	8000760 <HAL_RCC_OscConfig+0xbc>
 8000770:	e7f1      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8000772:	68e3      	ldr	r3, [r4, #12]
 8000774:	2b01      	cmp	r3, #1
 8000776:	d904      	bls.n	8000782 <HAL_RCC_OscConfig+0xde>
 8000778:	f44f 7196 	mov.w	r1, #300	; 0x12c
 800077c:	4871      	ldr	r0, [pc, #452]	; (8000944 <HAL_RCC_OscConfig+0x2a0>)
 800077e:	f001 feb8 	bl	80024f2 <assert_failed>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8000782:	6923      	ldr	r3, [r4, #16]
 8000784:	2b1f      	cmp	r3, #31
 8000786:	d904      	bls.n	8000792 <HAL_RCC_OscConfig+0xee>
 8000788:	f240 112d 	movw	r1, #301	; 0x12d
 800078c:	486d      	ldr	r0, [pc, #436]	; (8000944 <HAL_RCC_OscConfig+0x2a0>)
 800078e:	f001 feb0 	bl	80024f2 <assert_failed>
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8000792:	4b6d      	ldr	r3, [pc, #436]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
 8000794:	689a      	ldr	r2, [r3, #8]
 8000796:	f012 0f0c 	tst.w	r2, #12
 800079a:	d007      	beq.n	80007ac <HAL_RCC_OscConfig+0x108>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800079c:	689a      	ldr	r2, [r3, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800079e:	f002 020c 	and.w	r2, r2, #12
 80007a2:	2a08      	cmp	r2, #8
 80007a4:	d117      	bne.n	80007d6 <HAL_RCC_OscConfig+0x132>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80007a6:	685b      	ldr	r3, [r3, #4]
 80007a8:	0259      	lsls	r1, r3, #9
 80007aa:	d414      	bmi.n	80007d6 <HAL_RCC_OscConfig+0x132>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80007ac:	4b66      	ldr	r3, [pc, #408]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
 80007ae:	681a      	ldr	r2, [r3, #0]
 80007b0:	0792      	lsls	r2, r2, #30
 80007b2:	d502      	bpl.n	80007ba <HAL_RCC_OscConfig+0x116>
 80007b4:	68e2      	ldr	r2, [r4, #12]
 80007b6:	2a01      	cmp	r2, #1
 80007b8:	d1a5      	bne.n	8000706 <HAL_RCC_OscConfig+0x62>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80007ba:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80007bc:	21f8      	movs	r1, #248	; 0xf8
 80007be:	fa91 f1a1 	rbit	r1, r1
 80007c2:	6920      	ldr	r0, [r4, #16]
 80007c4:	fab1 f181 	clz	r1, r1
 80007c8:	fa00 f101 	lsl.w	r1, r0, r1
 80007cc:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80007d0:	430a      	orrs	r2, r1
 80007d2:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80007d4:	e02e      	b.n	8000834 <HAL_RCC_OscConfig+0x190>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80007d6:	68e2      	ldr	r2, [r4, #12]
 80007d8:	4b5c      	ldr	r3, [pc, #368]	; (800094c <HAL_RCC_OscConfig+0x2a8>)
 80007da:	b1ea      	cbz	r2, 8000818 <HAL_RCC_OscConfig+0x174>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80007dc:	2201      	movs	r2, #1
 80007de:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80007e0:	f7ff fd64 	bl	80002ac <HAL_GetTick>

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80007e4:	4d58      	ldr	r5, [pc, #352]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80007e6:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80007e8:	682b      	ldr	r3, [r5, #0]
 80007ea:	4857      	ldr	r0, [pc, #348]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
 80007ec:	079f      	lsls	r7, r3, #30
 80007ee:	d405      	bmi.n	80007fc <HAL_RCC_OscConfig+0x158>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80007f0:	f7ff fd5c 	bl	80002ac <HAL_GetTick>
 80007f4:	1b80      	subs	r0, r0, r6
 80007f6:	2802      	cmp	r0, #2
 80007f8:	d9f6      	bls.n	80007e8 <HAL_RCC_OscConfig+0x144>
 80007fa:	e7ac      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80007fc:	6803      	ldr	r3, [r0, #0]
 80007fe:	22f8      	movs	r2, #248	; 0xf8
 8000800:	fa92 f2a2 	rbit	r2, r2
 8000804:	6921      	ldr	r1, [r4, #16]
 8000806:	fab2 f282 	clz	r2, r2
 800080a:	fa01 f202 	lsl.w	r2, r1, r2
 800080e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000812:	4313      	orrs	r3, r2
 8000814:	6003      	str	r3, [r0, #0]
 8000816:	e00d      	b.n	8000834 <HAL_RCC_OscConfig+0x190>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000818:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800081a:	f7ff fd47 	bl	80002ac <HAL_GetTick>
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800081e:	4d4a      	ldr	r5, [pc, #296]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000820:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000822:	682b      	ldr	r3, [r5, #0]
 8000824:	0799      	lsls	r1, r3, #30
 8000826:	d505      	bpl.n	8000834 <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000828:	f7ff fd40 	bl	80002ac <HAL_GetTick>
 800082c:	1b80      	subs	r0, r0, r6
 800082e:	2802      	cmp	r0, #2
 8000830:	d9f7      	bls.n	8000822 <HAL_RCC_OscConfig+0x17e>
 8000832:	e790      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000834:	6823      	ldr	r3, [r4, #0]
 8000836:	071a      	lsls	r2, r3, #28
 8000838:	d403      	bmi.n	8000842 <HAL_RCC_OscConfig+0x19e>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800083a:	6823      	ldr	r3, [r4, #0]
 800083c:	075b      	lsls	r3, r3, #29
 800083e:	d428      	bmi.n	8000892 <HAL_RCC_OscConfig+0x1ee>
 8000840:	e052      	b.n	80008e8 <HAL_RCC_OscConfig+0x244>
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8000842:	6963      	ldr	r3, [r4, #20]
 8000844:	2b01      	cmp	r3, #1
 8000846:	d904      	bls.n	8000852 <HAL_RCC_OscConfig+0x1ae>
 8000848:	f240 116d 	movw	r1, #365	; 0x16d
 800084c:	483d      	ldr	r0, [pc, #244]	; (8000944 <HAL_RCC_OscConfig+0x2a0>)
 800084e:	f001 fe50 	bl	80024f2 <assert_failed>

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8000852:	6962      	ldr	r2, [r4, #20]
 8000854:	4b3e      	ldr	r3, [pc, #248]	; (8000950 <HAL_RCC_OscConfig+0x2ac>)
 8000856:	b172      	cbz	r2, 8000876 <HAL_RCC_OscConfig+0x1d2>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000858:	2201      	movs	r2, #1
 800085a:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800085c:	f7ff fd26 	bl	80002ac <HAL_GetTick>
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000860:	4d39      	ldr	r5, [pc, #228]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000862:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000864:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000866:	079f      	lsls	r7, r3, #30
 8000868:	d4e7      	bmi.n	800083a <HAL_RCC_OscConfig+0x196>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800086a:	f7ff fd1f 	bl	80002ac <HAL_GetTick>
 800086e:	1b80      	subs	r0, r0, r6
 8000870:	2802      	cmp	r0, #2
 8000872:	d9f7      	bls.n	8000864 <HAL_RCC_OscConfig+0x1c0>
 8000874:	e76f      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000876:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000878:	f7ff fd18 	bl	80002ac <HAL_GetTick>
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800087c:	4d32      	ldr	r5, [pc, #200]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800087e:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000880:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000882:	0798      	lsls	r0, r3, #30
 8000884:	d5d9      	bpl.n	800083a <HAL_RCC_OscConfig+0x196>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000886:	f7ff fd11 	bl	80002ac <HAL_GetTick>
 800088a:	1b80      	subs	r0, r0, r6
 800088c:	2802      	cmp	r0, #2
 800088e:	d9f7      	bls.n	8000880 <HAL_RCC_OscConfig+0x1dc>
 8000890:	e761      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8000892:	68a3      	ldr	r3, [r4, #8]
 8000894:	2b01      	cmp	r3, #1
 8000896:	d830      	bhi.n	80008fa <HAL_RCC_OscConfig+0x256>
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8000898:	2300      	movs	r3, #0
 800089a:	9301      	str	r3, [sp, #4]
 800089c:	4b2a      	ldr	r3, [pc, #168]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 800089e:	4d2d      	ldr	r5, [pc, #180]	; (8000954 <HAL_RCC_OscConfig+0x2b0>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80008a0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80008a2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80008a6:	641a      	str	r2, [r3, #64]	; 0x40
 80008a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80008aa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80008ae:	9301      	str	r3, [sp, #4]
 80008b0:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80008b2:	682b      	ldr	r3, [r5, #0]
 80008b4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80008b8:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 80008ba:	f7ff fcf7 	bl	80002ac <HAL_GetTick>
 80008be:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80008c0:	682b      	ldr	r3, [r5, #0]
 80008c2:	05d9      	lsls	r1, r3, #23
 80008c4:	d521      	bpl.n	800090a <HAL_RCC_OscConfig+0x266>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80008c6:	68a3      	ldr	r3, [r4, #8]
 80008c8:	4d1f      	ldr	r5, [pc, #124]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
 80008ca:	2b01      	cmp	r3, #1
 80008cc:	d123      	bne.n	8000916 <HAL_RCC_OscConfig+0x272>
 80008ce:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80008d0:	f043 0301 	orr.w	r3, r3, #1
 80008d4:	672b      	str	r3, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80008d6:	f7ff fce9 	bl	80002ac <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80008da:	4d1b      	ldr	r5, [pc, #108]	; (8000948 <HAL_RCC_OscConfig+0x2a4>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80008dc:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80008de:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80008e2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80008e4:	079a      	lsls	r2, r3, #30
 80008e6:	d527      	bpl.n	8000938 <HAL_RCC_OscConfig+0x294>
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 80008e8:	69a3      	ldr	r3, [r4, #24]
 80008ea:	2b02      	cmp	r3, #2
 80008ec:	d942      	bls.n	8000974 <HAL_RCC_OscConfig+0x2d0>
 80008ee:	f44f 71e6 	mov.w	r1, #460	; 0x1cc
 80008f2:	4814      	ldr	r0, [pc, #80]	; (8000944 <HAL_RCC_OscConfig+0x2a0>)
 80008f4:	f001 fdfd 	bl	80024f2 <assert_failed>
 80008f8:	e03c      	b.n	8000974 <HAL_RCC_OscConfig+0x2d0>
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 80008fa:	2b05      	cmp	r3, #5
 80008fc:	d0cc      	beq.n	8000898 <HAL_RCC_OscConfig+0x1f4>
 80008fe:	f240 1197 	movw	r1, #407	; 0x197
 8000902:	4810      	ldr	r0, [pc, #64]	; (8000944 <HAL_RCC_OscConfig+0x2a0>)
 8000904:	f001 fdf5 	bl	80024f2 <assert_failed>
 8000908:	e7c6      	b.n	8000898 <HAL_RCC_OscConfig+0x1f4>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800090a:	f7ff fccf 	bl	80002ac <HAL_GetTick>
 800090e:	1b80      	subs	r0, r0, r6
 8000910:	2802      	cmp	r0, #2
 8000912:	d9d5      	bls.n	80008c0 <HAL_RCC_OscConfig+0x21c>
 8000914:	e71f      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000916:	2b05      	cmp	r3, #5
 8000918:	d104      	bne.n	8000924 <HAL_RCC_OscConfig+0x280>
 800091a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800091c:	f043 0304 	orr.w	r3, r3, #4
 8000920:	672b      	str	r3, [r5, #112]	; 0x70
 8000922:	e7d4      	b.n	80008ce <HAL_RCC_OscConfig+0x22a>
 8000924:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8000926:	f022 0201 	bic.w	r2, r2, #1
 800092a:	672a      	str	r2, [r5, #112]	; 0x70
 800092c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 800092e:	f022 0204 	bic.w	r2, r2, #4
 8000932:	672a      	str	r2, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8000934:	b183      	cbz	r3, 8000958 <HAL_RCC_OscConfig+0x2b4>
 8000936:	e7ce      	b.n	80008d6 <HAL_RCC_OscConfig+0x232>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000938:	f7ff fcb8 	bl	80002ac <HAL_GetTick>
 800093c:	1b80      	subs	r0, r0, r6
 800093e:	42b8      	cmp	r0, r7
 8000940:	d9cf      	bls.n	80008e2 <HAL_RCC_OscConfig+0x23e>
 8000942:	e708      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
 8000944:	080027bc 	.word	0x080027bc
 8000948:	40023800 	.word	0x40023800
 800094c:	42470000 	.word	0x42470000
 8000950:	42470e80 	.word	0x42470e80
 8000954:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000958:	f7ff fca8 	bl	80002ac <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800095c:	f241 3788 	movw	r7, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000960:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000962:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000964:	079b      	lsls	r3, r3, #30
 8000966:	d5bf      	bpl.n	80008e8 <HAL_RCC_OscConfig+0x244>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000968:	f7ff fca0 	bl	80002ac <HAL_GetTick>
 800096c:	1b80      	subs	r0, r0, r6
 800096e:	42b8      	cmp	r0, r7
 8000970:	d9f7      	bls.n	8000962 <HAL_RCC_OscConfig+0x2be>
 8000972:	e6f0      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000974:	69a2      	ldr	r2, [r4, #24]
 8000976:	b90a      	cbnz	r2, 800097c <HAL_RCC_OscConfig+0x2d8>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8000978:	2000      	movs	r0, #0
 800097a:	e08c      	b.n	8000a96 <HAL_RCC_OscConfig+0x3f2>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800097c:	4e47      	ldr	r6, [pc, #284]	; (8000a9c <HAL_RCC_OscConfig+0x3f8>)
 800097e:	68b3      	ldr	r3, [r6, #8]
 8000980:	f003 030c 	and.w	r3, r3, #12
 8000984:	2b08      	cmp	r3, #8
 8000986:	f43f aebe 	beq.w	8000706 <HAL_RCC_OscConfig+0x62>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800098a:	2a02      	cmp	r2, #2
 800098c:	4d44      	ldr	r5, [pc, #272]	; (8000aa0 <HAL_RCC_OscConfig+0x3fc>)
 800098e:	d173      	bne.n	8000a78 <HAL_RCC_OscConfig+0x3d4>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 8000990:	69e3      	ldr	r3, [r4, #28]
 8000992:	f433 0380 	bics.w	r3, r3, #4194304	; 0x400000
 8000996:	d004      	beq.n	80009a2 <HAL_RCC_OscConfig+0x2fe>
 8000998:	f240 11d5 	movw	r1, #469	; 0x1d5
 800099c:	4841      	ldr	r0, [pc, #260]	; (8000aa4 <HAL_RCC_OscConfig+0x400>)
 800099e:	f001 fda8 	bl	80024f2 <assert_failed>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 80009a2:	6a23      	ldr	r3, [r4, #32]
 80009a4:	2b3f      	cmp	r3, #63	; 0x3f
 80009a6:	d904      	bls.n	80009b2 <HAL_RCC_OscConfig+0x30e>
 80009a8:	f44f 71eb 	mov.w	r1, #470	; 0x1d6
 80009ac:	483d      	ldr	r0, [pc, #244]	; (8000aa4 <HAL_RCC_OscConfig+0x400>)
 80009ae:	f001 fda0 	bl	80024f2 <assert_failed>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 80009b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80009b4:	3b32      	subs	r3, #50	; 0x32
 80009b6:	f5b3 7fbf 	cmp.w	r3, #382	; 0x17e
 80009ba:	d904      	bls.n	80009c6 <HAL_RCC_OscConfig+0x322>
 80009bc:	f240 11d7 	movw	r1, #471	; 0x1d7
 80009c0:	4838      	ldr	r0, [pc, #224]	; (8000aa4 <HAL_RCC_OscConfig+0x400>)
 80009c2:	f001 fd96 	bl	80024f2 <assert_failed>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 80009c6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80009c8:	2a08      	cmp	r2, #8
 80009ca:	d804      	bhi.n	80009d6 <HAL_RCC_OscConfig+0x332>
 80009cc:	f44f 73aa 	mov.w	r3, #340	; 0x154
 80009d0:	40d3      	lsrs	r3, r2
 80009d2:	07d8      	lsls	r0, r3, #31
 80009d4:	d404      	bmi.n	80009e0 <HAL_RCC_OscConfig+0x33c>
 80009d6:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 80009da:	4832      	ldr	r0, [pc, #200]	; (8000aa4 <HAL_RCC_OscConfig+0x400>)
 80009dc:	f001 fd89 	bl	80024f2 <assert_failed>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 80009e0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80009e2:	3b04      	subs	r3, #4
 80009e4:	2b0b      	cmp	r3, #11
 80009e6:	d904      	bls.n	80009f2 <HAL_RCC_OscConfig+0x34e>
 80009e8:	f240 11d9 	movw	r1, #473	; 0x1d9
 80009ec:	482d      	ldr	r0, [pc, #180]	; (8000aa4 <HAL_RCC_OscConfig+0x400>)
 80009ee:	f001 fd80 	bl	80024f2 <assert_failed>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80009f2:	2300      	movs	r3, #0
 80009f4:	602b      	str	r3, [r5, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80009f6:	f7ff fc59 	bl	80002ac <HAL_GetTick>
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80009fa:	4f28      	ldr	r7, [pc, #160]	; (8000a9c <HAL_RCC_OscConfig+0x3f8>)
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80009fc:	4680      	mov	r8, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80009fe:	683b      	ldr	r3, [r7, #0]
 8000a00:	4e26      	ldr	r6, [pc, #152]	; (8000a9c <HAL_RCC_OscConfig+0x3f8>)
 8000a02:	0199      	lsls	r1, r3, #6
 8000a04:	d506      	bpl.n	8000a14 <HAL_RCC_OscConfig+0x370>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000a06:	f7ff fc51 	bl	80002ac <HAL_GetTick>
 8000a0a:	ebc8 0000 	rsb	r0, r8, r0
 8000a0e:	2802      	cmp	r0, #2
 8000a10:	d9f5      	bls.n	80009fe <HAL_RCC_OscConfig+0x35a>
 8000a12:	e6a0      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
 8000a14:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8000a18:	fa92 f2a2 	rbit	r2, r2
 8000a1c:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8000a20:	fab2 fe82 	clz	lr, r2
 8000a24:	fa93 f3a3 	rbit	r3, r3
 8000a28:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 8000a2c:	fab3 f783 	clz	r7, r3
 8000a30:	fa92 f2a2 	rbit	r2, r2
 8000a34:	69e0      	ldr	r0, [r4, #28]
 8000a36:	6a23      	ldr	r3, [r4, #32]
 8000a38:	fab2 f182 	clz	r1, r2
 8000a3c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000a3e:	4303      	orrs	r3, r0
 8000a40:	fa02 f20e 	lsl.w	r2, r2, lr
 8000a44:	ea43 0002 	orr.w	r0, r3, r2
 8000a48:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000a4a:	085a      	lsrs	r2, r3, #1
 8000a4c:	3a01      	subs	r2, #1
 8000a4e:	fa02 f307 	lsl.w	r3, r2, r7
 8000a52:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000a54:	4303      	orrs	r3, r0
 8000a56:	408a      	lsls	r2, r1
 8000a58:	4313      	orrs	r3, r2
 8000a5a:	6073      	str	r3, [r6, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000a5c:	2301      	movs	r3, #1
 8000a5e:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000a60:	f7ff fc24 	bl	80002ac <HAL_GetTick>
 8000a64:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000a66:	6833      	ldr	r3, [r6, #0]
 8000a68:	019a      	lsls	r2, r3, #6
 8000a6a:	d485      	bmi.n	8000978 <HAL_RCC_OscConfig+0x2d4>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000a6c:	f7ff fc1e 	bl	80002ac <HAL_GetTick>
 8000a70:	1b00      	subs	r0, r0, r4
 8000a72:	2802      	cmp	r0, #2
 8000a74:	d9f7      	bls.n	8000a66 <HAL_RCC_OscConfig+0x3c2>
 8000a76:	e66e      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000a78:	2300      	movs	r3, #0
 8000a7a:	602b      	str	r3, [r5, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000a7c:	f7ff fc16 	bl	80002ac <HAL_GetTick>
 8000a80:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8000a82:	6833      	ldr	r3, [r6, #0]
 8000a84:	019b      	lsls	r3, r3, #6
 8000a86:	f57f af77 	bpl.w	8000978 <HAL_RCC_OscConfig+0x2d4>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000a8a:	f7ff fc0f 	bl	80002ac <HAL_GetTick>
 8000a8e:	1b00      	subs	r0, r0, r4
 8000a90:	2802      	cmp	r0, #2
 8000a92:	d9f6      	bls.n	8000a82 <HAL_RCC_OscConfig+0x3de>
 8000a94:	e65f      	b.n	8000756 <HAL_RCC_OscConfig+0xb2>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8000a96:	b002      	add	sp, #8
 8000a98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000a9c:	40023800 	.word	0x40023800
 8000aa0:	42470060 	.word	0x42470060
 8000aa4:	080027bc 	.word	0x080027bc

08000aa8 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000aa8:	491b      	ldr	r1, [pc, #108]	; (8000b18 <HAL_RCC_GetSysClockFreq+0x70>)
 8000aaa:	688b      	ldr	r3, [r1, #8]
 8000aac:	f003 030c 	and.w	r3, r3, #12
 8000ab0:	2b04      	cmp	r3, #4
 8000ab2:	d02c      	beq.n	8000b0e <HAL_RCC_GetSysClockFreq+0x66>
 8000ab4:	2b08      	cmp	r3, #8
 8000ab6:	d12c      	bne.n	8000b12 <HAL_RCC_GetSysClockFreq+0x6a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000ab8:	6848      	ldr	r0, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8000aba:	684b      	ldr	r3, [r1, #4]
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000abc:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8000ac0:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8000ac4:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8000ac8:	684b      	ldr	r3, [r1, #4]
 8000aca:	fa92 f2a2 	rbit	r2, r2
 8000ace:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8000ad2:	fab2 f282 	clz	r2, r2
 8000ad6:	ea01 0103 	and.w	r1, r1, r3
 8000ada:	fa21 f102 	lsr.w	r1, r1, r2
 8000ade:	bf14      	ite	ne
 8000ae0:	4a0e      	ldrne	r2, [pc, #56]	; (8000b1c <HAL_RCC_GetSysClockFreq+0x74>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8000ae2:	4a0f      	ldreq	r2, [pc, #60]	; (8000b20 <HAL_RCC_GetSysClockFreq+0x78>)
 8000ae4:	fbb2 f0f0 	udiv	r0, r2, r0
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8000ae8:	4a0b      	ldr	r2, [pc, #44]	; (8000b18 <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8000aea:	fb00 f301 	mul.w	r3, r0, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8000aee:	6852      	ldr	r2, [r2, #4]
 8000af0:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8000af4:	fa90 f0a0 	rbit	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8000af8:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8000afc:	fab0 f080 	clz	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8000b00:	fa22 f000 	lsr.w	r0, r2, r0
 8000b04:	3001      	adds	r0, #1
 8000b06:	0040      	lsls	r0, r0, #1
 8000b08:	fbb3 f0f0 	udiv	r0, r3, r0
 8000b0c:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8000b0e:	4803      	ldr	r0, [pc, #12]	; (8000b1c <HAL_RCC_GetSysClockFreq+0x74>)
 8000b10:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8000b12:	4803      	ldr	r0, [pc, #12]	; (8000b20 <HAL_RCC_GetSysClockFreq+0x78>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000b14:	4770      	bx	lr
 8000b16:	bf00      	nop
 8000b18:	40023800 	.word	0x40023800
 8000b1c:	016e3600 	.word	0x016e3600
 8000b20:	00f42400 	.word	0x00f42400

08000b24 <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0U;   
 
  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8000b24:	6803      	ldr	r3, [r0, #0]
 8000b26:	3b01      	subs	r3, #1
 8000b28:	2b0e      	cmp	r3, #14
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000b2a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000b2e:	4604      	mov	r4, r0
 8000b30:	460e      	mov	r6, r1
  uint32_t tickstart = 0U;   
 
  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8000b32:	d904      	bls.n	8000b3e <HAL_RCC_ClockConfig+0x1a>
 8000b34:	f240 2137 	movw	r1, #567	; 0x237
 8000b38:	487a      	ldr	r0, [pc, #488]	; (8000d24 <HAL_RCC_ClockConfig+0x200>)
 8000b3a:	f001 fcda 	bl	80024f2 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8000b3e:	2e0f      	cmp	r6, #15
 8000b40:	d904      	bls.n	8000b4c <HAL_RCC_ClockConfig+0x28>
 8000b42:	f44f 710e 	mov.w	r1, #568	; 0x238
 8000b46:	4877      	ldr	r0, [pc, #476]	; (8000d24 <HAL_RCC_ClockConfig+0x200>)
 8000b48:	f001 fcd3 	bl	80024f2 <assert_failed>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000b4c:	4b76      	ldr	r3, [pc, #472]	; (8000d28 <HAL_RCC_ClockConfig+0x204>)
 8000b4e:	681a      	ldr	r2, [r3, #0]
 8000b50:	f002 020f 	and.w	r2, r2, #15
 8000b54:	4296      	cmp	r6, r2
 8000b56:	d803      	bhi.n	8000b60 <HAL_RCC_ClockConfig+0x3c>
      return HAL_ERROR;
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000b58:	6823      	ldr	r3, [r4, #0]
 8000b5a:	0798      	lsls	r0, r3, #30
 8000b5c:	d40a      	bmi.n	8000b74 <HAL_RCC_ClockConfig+0x50>
 8000b5e:	e027      	b.n	8000bb0 <HAL_RCC_ClockConfig+0x8c>
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000b60:	b2f2      	uxtb	r2, r6
 8000b62:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000b64:	681b      	ldr	r3, [r3, #0]
 8000b66:	f003 030f 	and.w	r3, r3, #15
 8000b6a:	429e      	cmp	r6, r3
 8000b6c:	d0f4      	beq.n	8000b58 <HAL_RCC_ClockConfig+0x34>
    {
      return HAL_ERROR;
 8000b6e:	2001      	movs	r0, #1
 8000b70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8000b74:	68a3      	ldr	r3, [r4, #8]
 8000b76:	f033 0280 	bics.w	r2, r3, #128	; 0x80
 8000b7a:	d012      	beq.n	8000ba2 <HAL_RCC_ClockConfig+0x7e>
 8000b7c:	f023 0220 	bic.w	r2, r3, #32
 8000b80:	2a90      	cmp	r2, #144	; 0x90
 8000b82:	d00e      	beq.n	8000ba2 <HAL_RCC_ClockConfig+0x7e>
 8000b84:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8000b88:	2aa0      	cmp	r2, #160	; 0xa0
 8000b8a:	d00a      	beq.n	8000ba2 <HAL_RCC_ClockConfig+0x7e>
 8000b8c:	f023 0210 	bic.w	r2, r3, #16
 8000b90:	2ac0      	cmp	r2, #192	; 0xc0
 8000b92:	d006      	beq.n	8000ba2 <HAL_RCC_ClockConfig+0x7e>
 8000b94:	2bf0      	cmp	r3, #240	; 0xf0
 8000b96:	d004      	beq.n	8000ba2 <HAL_RCC_ClockConfig+0x7e>
 8000b98:	f240 214f 	movw	r1, #591	; 0x24f
 8000b9c:	4861      	ldr	r0, [pc, #388]	; (8000d24 <HAL_RCC_ClockConfig+0x200>)
 8000b9e:	f001 fca8 	bl	80024f2 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000ba2:	4962      	ldr	r1, [pc, #392]	; (8000d2c <HAL_RCC_ClockConfig+0x208>)
 8000ba4:	688b      	ldr	r3, [r1, #8]
 8000ba6:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8000baa:	68a3      	ldr	r3, [r4, #8]
 8000bac:	4313      	orrs	r3, r2
 8000bae:	608b      	str	r3, [r1, #8]
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000bb0:	6823      	ldr	r3, [r4, #0]
 8000bb2:	07d9      	lsls	r1, r3, #31
 8000bb4:	d406      	bmi.n	8000bc4 <HAL_RCC_ClockConfig+0xa0>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8000bb6:	4b5c      	ldr	r3, [pc, #368]	; (8000d28 <HAL_RCC_ClockConfig+0x204>)
 8000bb8:	681a      	ldr	r2, [r3, #0]
 8000bba:	f002 020f 	and.w	r2, r2, #15
 8000bbe:	4296      	cmp	r6, r2
 8000bc0:	d359      	bcc.n	8000c76 <HAL_RCC_ClockConfig+0x152>
 8000bc2:	e060      	b.n	8000c86 <HAL_RCC_ClockConfig+0x162>
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8000bc4:	6863      	ldr	r3, [r4, #4]
 8000bc6:	2b03      	cmp	r3, #3
 8000bc8:	d904      	bls.n	8000bd4 <HAL_RCC_ClockConfig+0xb0>
 8000bca:	f240 2156 	movw	r1, #598	; 0x256
 8000bce:	4855      	ldr	r0, [pc, #340]	; (8000d24 <HAL_RCC_ClockConfig+0x200>)
 8000bd0:	f001 fc8f 	bl	80024f2 <assert_failed>
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000bd4:	6863      	ldr	r3, [r4, #4]
 8000bd6:	4a55      	ldr	r2, [pc, #340]	; (8000d2c <HAL_RCC_ClockConfig+0x208>)
 8000bd8:	2b01      	cmp	r3, #1
 8000bda:	d103      	bne.n	8000be4 <HAL_RCC_ClockConfig+0xc0>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000bdc:	6812      	ldr	r2, [r2, #0]
 8000bde:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8000be2:	e008      	b.n	8000bf6 <HAL_RCC_ClockConfig+0xd2>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8000be4:	1e99      	subs	r1, r3, #2
 8000be6:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000be8:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8000bea:	d802      	bhi.n	8000bf2 <HAL_RCC_ClockConfig+0xce>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000bec:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8000bf0:	e001      	b.n	8000bf6 <HAL_RCC_ClockConfig+0xd2>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000bf2:	f012 0f02 	tst.w	r2, #2
 8000bf6:	d0ba      	beq.n	8000b6e <HAL_RCC_ClockConfig+0x4a>
      {
        return HAL_ERROR;
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000bf8:	4d4c      	ldr	r5, [pc, #304]	; (8000d2c <HAL_RCC_ClockConfig+0x208>)
 8000bfa:	68aa      	ldr	r2, [r5, #8]
 8000bfc:	f022 0203 	bic.w	r2, r2, #3
 8000c00:	4313      	orrs	r3, r2
 8000c02:	60ab      	str	r3, [r5, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8000c04:	f7ff fb52 	bl	80002ac <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000c08:	6863      	ldr	r3, [r4, #4]
 8000c0a:	2b01      	cmp	r3, #1
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8000c0c:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c0e:	f241 3888 	movw	r8, #5000	; 0x1388
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000c12:	d10c      	bne.n	8000c2e <HAL_RCC_ClockConfig+0x10a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8000c14:	68ab      	ldr	r3, [r5, #8]
 8000c16:	f003 030c 	and.w	r3, r3, #12
 8000c1a:	2b04      	cmp	r3, #4
 8000c1c:	d0cb      	beq.n	8000bb6 <HAL_RCC_ClockConfig+0x92>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c1e:	f7ff fb45 	bl	80002ac <HAL_GetTick>
 8000c22:	1bc0      	subs	r0, r0, r7
 8000c24:	4540      	cmp	r0, r8
 8000c26:	d9f5      	bls.n	8000c14 <HAL_RCC_ClockConfig+0xf0>
        {
          return HAL_TIMEOUT;
 8000c28:	2003      	movs	r0, #3
 8000c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000c2e:	2b02      	cmp	r3, #2
 8000c30:	d10a      	bne.n	8000c48 <HAL_RCC_ClockConfig+0x124>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000c32:	68ab      	ldr	r3, [r5, #8]
 8000c34:	f003 030c 	and.w	r3, r3, #12
 8000c38:	2b08      	cmp	r3, #8
 8000c3a:	d0bc      	beq.n	8000bb6 <HAL_RCC_ClockConfig+0x92>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c3c:	f7ff fb36 	bl	80002ac <HAL_GetTick>
 8000c40:	1bc0      	subs	r0, r0, r7
 8000c42:	4540      	cmp	r0, r8
 8000c44:	d9f5      	bls.n	8000c32 <HAL_RCC_ClockConfig+0x10e>
 8000c46:	e7ef      	b.n	8000c28 <HAL_RCC_ClockConfig+0x104>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 8000c48:	2b03      	cmp	r3, #3
 8000c4a:	d10f      	bne.n	8000c6c <HAL_RCC_ClockConfig+0x148>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8000c4c:	68ab      	ldr	r3, [r5, #8]
 8000c4e:	f003 030c 	and.w	r3, r3, #12
 8000c52:	2b0c      	cmp	r3, #12
 8000c54:	d0af      	beq.n	8000bb6 <HAL_RCC_ClockConfig+0x92>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c56:	f7ff fb29 	bl	80002ac <HAL_GetTick>
 8000c5a:	1bc0      	subs	r0, r0, r7
 8000c5c:	4540      	cmp	r0, r8
 8000c5e:	d9f5      	bls.n	8000c4c <HAL_RCC_ClockConfig+0x128>
 8000c60:	e7e2      	b.n	8000c28 <HAL_RCC_ClockConfig+0x104>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c62:	f7ff fb23 	bl	80002ac <HAL_GetTick>
 8000c66:	1bc0      	subs	r0, r0, r7
 8000c68:	4540      	cmp	r0, r8
 8000c6a:	d8dd      	bhi.n	8000c28 <HAL_RCC_ClockConfig+0x104>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8000c6c:	68ab      	ldr	r3, [r5, #8]
 8000c6e:	f013 0f0c 	tst.w	r3, #12
 8000c72:	d1f6      	bne.n	8000c62 <HAL_RCC_ClockConfig+0x13e>
 8000c74:	e79f      	b.n	8000bb6 <HAL_RCC_ClockConfig+0x92>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000c76:	b2f2      	uxtb	r2, r6
 8000c78:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000c7a:	681b      	ldr	r3, [r3, #0]
 8000c7c:	f003 030f 	and.w	r3, r3, #15
 8000c80:	429e      	cmp	r6, r3
 8000c82:	f47f af74 	bne.w	8000b6e <HAL_RCC_ClockConfig+0x4a>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000c86:	6823      	ldr	r3, [r4, #0]
 8000c88:	075a      	lsls	r2, r3, #29
 8000c8a:	d517      	bpl.n	8000cbc <HAL_RCC_ClockConfig+0x198>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 8000c8c:	68e3      	ldr	r3, [r4, #12]
 8000c8e:	f433 5280 	bics.w	r2, r3, #4096	; 0x1000
 8000c92:	d00c      	beq.n	8000cae <HAL_RCC_ClockConfig+0x18a>
 8000c94:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 8000c98:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
 8000c9c:	d007      	beq.n	8000cae <HAL_RCC_ClockConfig+0x18a>
 8000c9e:	f5b3 5fc0 	cmp.w	r3, #6144	; 0x1800
 8000ca2:	d004      	beq.n	8000cae <HAL_RCC_ClockConfig+0x18a>
 8000ca4:	f44f 712d 	mov.w	r1, #692	; 0x2b4
 8000ca8:	481e      	ldr	r0, [pc, #120]	; (8000d24 <HAL_RCC_ClockConfig+0x200>)
 8000caa:	f001 fc22 	bl	80024f2 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8000cae:	491f      	ldr	r1, [pc, #124]	; (8000d2c <HAL_RCC_ClockConfig+0x208>)
 8000cb0:	688b      	ldr	r3, [r1, #8]
 8000cb2:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8000cb6:	68e3      	ldr	r3, [r4, #12]
 8000cb8:	4313      	orrs	r3, r2
 8000cba:	608b      	str	r3, [r1, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000cbc:	6823      	ldr	r3, [r4, #0]
 8000cbe:	071b      	lsls	r3, r3, #28
 8000cc0:	d518      	bpl.n	8000cf4 <HAL_RCC_ClockConfig+0x1d0>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 8000cc2:	6923      	ldr	r3, [r4, #16]
 8000cc4:	f433 5280 	bics.w	r2, r3, #4096	; 0x1000
 8000cc8:	d00c      	beq.n	8000ce4 <HAL_RCC_ClockConfig+0x1c0>
 8000cca:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 8000cce:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
 8000cd2:	d007      	beq.n	8000ce4 <HAL_RCC_ClockConfig+0x1c0>
 8000cd4:	f5b3 5fc0 	cmp.w	r3, #6144	; 0x1800
 8000cd8:	d004      	beq.n	8000ce4 <HAL_RCC_ClockConfig+0x1c0>
 8000cda:	f240 21bb 	movw	r1, #699	; 0x2bb
 8000cde:	4811      	ldr	r0, [pc, #68]	; (8000d24 <HAL_RCC_ClockConfig+0x200>)
 8000ce0:	f001 fc07 	bl	80024f2 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8000ce4:	4a11      	ldr	r2, [pc, #68]	; (8000d2c <HAL_RCC_ClockConfig+0x208>)
 8000ce6:	6921      	ldr	r1, [r4, #16]
 8000ce8:	6893      	ldr	r3, [r2, #8]
 8000cea:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000cee:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8000cf2:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8000cf4:	f7ff fed8 	bl	8000aa8 <HAL_RCC_GetSysClockFreq>
 8000cf8:	4b0c      	ldr	r3, [pc, #48]	; (8000d2c <HAL_RCC_ClockConfig+0x208>)
 8000cfa:	22f0      	movs	r2, #240	; 0xf0
 8000cfc:	689b      	ldr	r3, [r3, #8]
 8000cfe:	fa92 f2a2 	rbit	r2, r2
 8000d02:	fab2 f282 	clz	r2, r2
 8000d06:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8000d0a:	40d3      	lsrs	r3, r2
 8000d0c:	4a08      	ldr	r2, [pc, #32]	; (8000d30 <HAL_RCC_ClockConfig+0x20c>)
 8000d0e:	5cd3      	ldrb	r3, [r2, r3]
 8000d10:	40d8      	lsrs	r0, r3
 8000d12:	4b08      	ldr	r3, [pc, #32]	; (8000d34 <HAL_RCC_ClockConfig+0x210>)
 8000d14:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8000d16:	2000      	movs	r0, #0
 8000d18:	f7ff fa92 	bl	8000240 <HAL_InitTick>
  
  return HAL_OK;
 8000d1c:	2000      	movs	r0, #0
}
 8000d1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000d22:	bf00      	nop
 8000d24:	080027bc 	.word	0x080027bc
 8000d28:	40023c00 	.word	0x40023c00
 8000d2c:	40023800 	.word	0x40023800
 8000d30:	080027ac 	.word	0x080027ac
 8000d34:	20000004 	.word	0x20000004

08000d38 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8000d38:	4b01      	ldr	r3, [pc, #4]	; (8000d40 <HAL_RCC_GetHCLKFreq+0x8>)
 8000d3a:	6818      	ldr	r0, [r3, #0]
 8000d3c:	4770      	bx	lr
 8000d3e:	bf00      	nop
 8000d40:	20000004 	.word	0x20000004

08000d44 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8000d44:	4b08      	ldr	r3, [pc, #32]	; (8000d68 <HAL_RCC_GetPCLK1Freq+0x24>)
 8000d46:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 8000d4a:	689b      	ldr	r3, [r3, #8]
 8000d4c:	fa92 f2a2 	rbit	r2, r2
 8000d50:	fab2 f282 	clz	r2, r2
 8000d54:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8000d58:	40d3      	lsrs	r3, r2
 8000d5a:	4a04      	ldr	r2, [pc, #16]	; (8000d6c <HAL_RCC_GetPCLK1Freq+0x28>)
 8000d5c:	5cd3      	ldrb	r3, [r2, r3]
 8000d5e:	4a04      	ldr	r2, [pc, #16]	; (8000d70 <HAL_RCC_GetPCLK1Freq+0x2c>)
 8000d60:	6810      	ldr	r0, [r2, #0]
}
 8000d62:	40d8      	lsrs	r0, r3
 8000d64:	4770      	bx	lr
 8000d66:	bf00      	nop
 8000d68:	40023800 	.word	0x40023800
 8000d6c:	080027ac 	.word	0x080027ac
 8000d70:	20000004 	.word	0x20000004

08000d74 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8000d74:	4b08      	ldr	r3, [pc, #32]	; (8000d98 <HAL_RCC_GetPCLK2Freq+0x24>)
 8000d76:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 8000d7a:	689b      	ldr	r3, [r3, #8]
 8000d7c:	fa92 f2a2 	rbit	r2, r2
 8000d80:	fab2 f282 	clz	r2, r2
 8000d84:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8000d88:	40d3      	lsrs	r3, r2
 8000d8a:	4a04      	ldr	r2, [pc, #16]	; (8000d9c <HAL_RCC_GetPCLK2Freq+0x28>)
 8000d8c:	5cd3      	ldrb	r3, [r2, r3]
 8000d8e:	4a04      	ldr	r2, [pc, #16]	; (8000da0 <HAL_RCC_GetPCLK2Freq+0x2c>)
 8000d90:	6810      	ldr	r0, [r2, #0]
} 
 8000d92:	40d8      	lsrs	r0, r3
 8000d94:	4770      	bx	lr
 8000d96:	bf00      	nop
 8000d98:	40023800 	.word	0x40023800
 8000d9c:	080027ac 	.word	0x080027ac
 8000da0:	20000004 	.word	0x20000004

08000da4 <SD_CmdResp2Error>:
  */
static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8000da4:	6803      	ldr	r3, [r0, #0]
 8000da6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000da8:	f012 0f45 	tst.w	r2, #69	; 0x45
 8000dac:	d0fb      	beq.n	8000da6 <SD_CmdResp2Error+0x2>
  {
  }
    
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8000dae:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000db0:	0752      	lsls	r2, r2, #29
 8000db2:	d503      	bpl.n	8000dbc <SD_CmdResp2Error+0x18>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8000db4:	2204      	movs	r2, #4
 8000db6:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8000db8:	2003      	movs	r0, #3
 8000dba:	4770      	bx	lr
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8000dbc:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8000dbe:	f010 0001 	ands.w	r0, r0, #1
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8000dc2:	bf15      	itete	ne
 8000dc4:	2001      	movne	r0, #1
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000dc6:	f240 52ff 	movweq	r2, #1535	; 0x5ff
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8000dca:	6398      	strne	r0, [r3, #56]	; 0x38
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000dcc:	639a      	streq	r2, [r3, #56]	; 0x38
  
  return errorstate;
}
 8000dce:	4770      	bx	lr

08000dd0 <SD_IsCardProgramming>:
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8000dd0:	b570      	push	{r4, r5, r6, lr}
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8000dd2:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8000dd4:	b086      	sub	sp, #24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8000dd6:	041b      	lsls	r3, r3, #16
 8000dd8:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8000dda:	230d      	movs	r3, #13
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8000ddc:	4605      	mov	r5, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8000dde:	9302      	str	r3, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8000de0:	2340      	movs	r3, #64	; 0x40
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 8000de2:	2200      	movs	r2, #0
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8000de4:	9303      	str	r3, [sp, #12]
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8000de6:	460e      	mov	r6, r1
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8000de8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000dec:	a901      	add	r1, sp, #4
 8000dee:	6800      	ldr	r0, [r0, #0]
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 8000df0:	9200      	str	r2, [sp, #0]
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8000df2:	9204      	str	r2, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8000df4:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000df6:	f001 f951 	bl	800209c <SDIO_SendCommand>
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8000dfa:	6828      	ldr	r0, [r5, #0]
 8000dfc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000dfe:	f013 0f45 	tst.w	r3, #69	; 0x45
 8000e02:	d0fb      	beq.n	8000dfc <SD_IsCardProgramming+0x2c>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8000e04:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000e06:	075b      	lsls	r3, r3, #29
 8000e08:	d503      	bpl.n	8000e12 <SD_IsCardProgramming+0x42>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8000e0a:	2304      	movs	r3, #4
 8000e0c:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8000e0e:	2003      	movs	r0, #3
 8000e10:	e07c      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8000e12:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000e14:	f013 0401 	ands.w	r4, r3, #1
 8000e18:	d003      	beq.n	8000e22 <SD_IsCardProgramming+0x52>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8000e1a:	2301      	movs	r3, #1
 8000e1c:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8000e1e:	4618      	mov	r0, r3
 8000e20:	e074      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if((uint32_t)SDIO_GetCommandResponse(hsd->Instance) != SD_CMD_SEND_STATUS)
 8000e22:	f001 f97b 	bl	800211c <SDIO_GetCommandResponse>
 8000e26:	280d      	cmp	r0, #13
 8000e28:	d001      	beq.n	8000e2e <SD_IsCardProgramming+0x5e>
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8000e2a:	2010      	movs	r0, #16
 8000e2c:	e06e      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000e2e:	682b      	ldr	r3, [r5, #0]
 8000e30:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8000e34:	639a      	str	r2, [r3, #56]	; 0x38
  
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
 8000e36:	4620      	mov	r0, r4
 8000e38:	f001 f974 	bl	8002124 <SDIO_GetResponse>
 8000e3c:	9000      	str	r0, [sp, #0]
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 8000e3e:	9b00      	ldr	r3, [sp, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8000e40:	4833      	ldr	r0, [pc, #204]	; (8000f10 <SD_IsCardProgramming+0x140>)
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 8000e42:	f3c3 2343 	ubfx	r3, r3, #9, #4
 8000e46:	7033      	strb	r3, [r6, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8000e48:	9b00      	ldr	r3, [sp, #0]
 8000e4a:	4018      	ands	r0, r3
 8000e4c:	2800      	cmp	r0, #0
 8000e4e:	d05d      	beq.n	8000f0c <SD_IsCardProgramming+0x13c>
  {
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8000e50:	9b00      	ldr	r3, [sp, #0]
 8000e52:	2b00      	cmp	r3, #0
 8000e54:	db39      	blt.n	8000eca <SD_IsCardProgramming+0xfa>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8000e56:	9b00      	ldr	r3, [sp, #0]
 8000e58:	005d      	lsls	r5, r3, #1
 8000e5a:	d438      	bmi.n	8000ece <SD_IsCardProgramming+0xfe>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8000e5c:	9b00      	ldr	r3, [sp, #0]
 8000e5e:	009c      	lsls	r4, r3, #2
 8000e60:	d437      	bmi.n	8000ed2 <SD_IsCardProgramming+0x102>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8000e62:	9b00      	ldr	r3, [sp, #0]
 8000e64:	00d9      	lsls	r1, r3, #3
 8000e66:	d436      	bmi.n	8000ed6 <SD_IsCardProgramming+0x106>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8000e68:	9b00      	ldr	r3, [sp, #0]
 8000e6a:	011a      	lsls	r2, r3, #4
 8000e6c:	d435      	bmi.n	8000eda <SD_IsCardProgramming+0x10a>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8000e6e:	9b00      	ldr	r3, [sp, #0]
 8000e70:	015b      	lsls	r3, r3, #5
 8000e72:	d434      	bmi.n	8000ede <SD_IsCardProgramming+0x10e>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8000e74:	9b00      	ldr	r3, [sp, #0]
 8000e76:	01de      	lsls	r6, r3, #7
 8000e78:	d433      	bmi.n	8000ee2 <SD_IsCardProgramming+0x112>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8000e7a:	9b00      	ldr	r3, [sp, #0]
 8000e7c:	021d      	lsls	r5, r3, #8
 8000e7e:	d432      	bmi.n	8000ee6 <SD_IsCardProgramming+0x116>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((responseR1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8000e80:	9b00      	ldr	r3, [sp, #0]
 8000e82:	025c      	lsls	r4, r3, #9
 8000e84:	d4d1      	bmi.n	8000e2a <SD_IsCardProgramming+0x5a>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8000e86:	9b00      	ldr	r3, [sp, #0]
 8000e88:	0299      	lsls	r1, r3, #10
 8000e8a:	d42e      	bmi.n	8000eea <SD_IsCardProgramming+0x11a>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8000e8c:	9b00      	ldr	r3, [sp, #0]
 8000e8e:	02da      	lsls	r2, r3, #11
 8000e90:	d42d      	bmi.n	8000eee <SD_IsCardProgramming+0x11e>
  {
    return(SD_CC_ERROR);
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8000e92:	9b00      	ldr	r3, [sp, #0]
 8000e94:	031b      	lsls	r3, r3, #12
 8000e96:	d42c      	bmi.n	8000ef2 <SD_IsCardProgramming+0x122>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8000e98:	9b00      	ldr	r3, [sp, #0]
 8000e9a:	035e      	lsls	r6, r3, #13
 8000e9c:	d42b      	bmi.n	8000ef6 <SD_IsCardProgramming+0x126>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8000e9e:	9b00      	ldr	r3, [sp, #0]
 8000ea0:	039d      	lsls	r5, r3, #14
 8000ea2:	d42a      	bmi.n	8000efa <SD_IsCardProgramming+0x12a>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8000ea4:	9b00      	ldr	r3, [sp, #0]
 8000ea6:	03dc      	lsls	r4, r3, #15
 8000ea8:	d429      	bmi.n	8000efe <SD_IsCardProgramming+0x12e>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8000eaa:	9b00      	ldr	r3, [sp, #0]
 8000eac:	0419      	lsls	r1, r3, #16
 8000eae:	d428      	bmi.n	8000f02 <SD_IsCardProgramming+0x132>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8000eb0:	9b00      	ldr	r3, [sp, #0]
 8000eb2:	045a      	lsls	r2, r3, #17
 8000eb4:	d427      	bmi.n	8000f06 <SD_IsCardProgramming+0x136>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8000eb6:	9b00      	ldr	r3, [sp, #0]
 8000eb8:	049b      	lsls	r3, r3, #18
 8000eba:	d426      	bmi.n	8000f0a <SD_IsCardProgramming+0x13a>
  {
    return(SD_ERASE_RESET);
  }
  
  if((responseR1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
 8000ebc:	9b00      	ldr	r3, [sp, #0]
  {
    return(SD_AKE_SEQ_ERROR);
 8000ebe:	f013 0f08 	tst.w	r3, #8
 8000ec2:	bf0c      	ite	eq
 8000ec4:	2000      	moveq	r0, #0
 8000ec6:	201a      	movne	r0, #26
 8000ec8:	e020      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8000eca:	201c      	movs	r0, #28
 8000ecc:	e01e      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8000ece:	2009      	movs	r0, #9
 8000ed0:	e01c      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8000ed2:	200a      	movs	r0, #10
 8000ed4:	e01a      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8000ed6:	200b      	movs	r0, #11
 8000ed8:	e018      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8000eda:	200c      	movs	r0, #12
 8000edc:	e016      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8000ede:	200d      	movs	r0, #13
 8000ee0:	e014      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8000ee2:	200e      	movs	r0, #14
 8000ee4:	e012      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8000ee6:	200f      	movs	r0, #15
 8000ee8:	e010      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8000eea:	2011      	movs	r0, #17
 8000eec:	e00e      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8000eee:	2012      	movs	r0, #18
 8000ef0:	e00c      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8000ef2:	2013      	movs	r0, #19
 8000ef4:	e00a      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8000ef6:	2014      	movs	r0, #20
 8000ef8:	e008      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8000efa:	2015      	movs	r0, #21
 8000efc:	e006      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8000efe:	2016      	movs	r0, #22
 8000f00:	e004      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8000f02:	2017      	movs	r0, #23
 8000f04:	e002      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8000f06:	2018      	movs	r0, #24
 8000f08:	e000      	b.n	8000f0c <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8000f0a:	2019      	movs	r0, #25
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}   
 8000f0c:	b006      	add	sp, #24
 8000f0e:	bd70      	pop	{r4, r5, r6, pc}
 8000f10:	fdffe008 	.word	0xfdffe008

08000f14 <SD_CmdResp1Error>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8000f14:	b570      	push	{r4, r5, r6, lr}
 8000f16:	4605      	mov	r5, r0
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8000f18:	6800      	ldr	r0, [r0, #0]
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8000f1a:	460e      	mov	r6, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8000f1c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000f1e:	f013 0f45 	tst.w	r3, #69	; 0x45
 8000f22:	d0fb      	beq.n	8000f1c <SD_CmdResp1Error+0x8>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8000f24:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000f26:	075b      	lsls	r3, r3, #29
 8000f28:	d503      	bpl.n	8000f32 <SD_CmdResp1Error+0x1e>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8000f2a:	2304      	movs	r3, #4
 8000f2c:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8000f2e:	2003      	movs	r0, #3
 8000f30:	bd70      	pop	{r4, r5, r6, pc}
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8000f32:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000f34:	f013 0401 	ands.w	r4, r3, #1
 8000f38:	d002      	beq.n	8000f40 <SD_CmdResp1Error+0x2c>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8000f3a:	2301      	movs	r3, #1
 8000f3c:	6383      	str	r3, [r0, #56]	; 0x38
 8000f3e:	e039      	b.n	8000fb4 <SD_CmdResp1Error+0xa0>
    
    return errorstate;
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8000f40:	f001 f8ec 	bl	800211c <SDIO_GetCommandResponse>
 8000f44:	42b0      	cmp	r0, r6
 8000f46:	d001      	beq.n	8000f4c <SD_CmdResp1Error+0x38>
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8000f48:	2010      	movs	r0, #16
 8000f4a:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000f4c:	682b      	ldr	r3, [r5, #0]
 8000f4e:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8000f52:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8000f54:	4620      	mov	r0, r4
 8000f56:	f001 f8e5 	bl	8002124 <SDIO_GetResponse>
  
  if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8000f5a:	4b28      	ldr	r3, [pc, #160]	; (8000ffc <SD_CmdResp1Error+0xe8>)
 8000f5c:	4003      	ands	r3, r0
 8000f5e:	b34b      	cbz	r3, 8000fb4 <SD_CmdResp1Error+0xa0>
  {
    return errorstate;
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8000f60:	2800      	cmp	r0, #0
 8000f62:	db29      	blt.n	8000fb8 <SD_CmdResp1Error+0xa4>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8000f64:	0045      	lsls	r5, r0, #1
 8000f66:	d429      	bmi.n	8000fbc <SD_CmdResp1Error+0xa8>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8000f68:	0084      	lsls	r4, r0, #2
 8000f6a:	d429      	bmi.n	8000fc0 <SD_CmdResp1Error+0xac>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8000f6c:	00c1      	lsls	r1, r0, #3
 8000f6e:	d429      	bmi.n	8000fc4 <SD_CmdResp1Error+0xb0>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8000f70:	0102      	lsls	r2, r0, #4
 8000f72:	d429      	bmi.n	8000fc8 <SD_CmdResp1Error+0xb4>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8000f74:	0143      	lsls	r3, r0, #5
 8000f76:	d429      	bmi.n	8000fcc <SD_CmdResp1Error+0xb8>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8000f78:	01c6      	lsls	r6, r0, #7
 8000f7a:	d429      	bmi.n	8000fd0 <SD_CmdResp1Error+0xbc>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8000f7c:	0205      	lsls	r5, r0, #8
 8000f7e:	d429      	bmi.n	8000fd4 <SD_CmdResp1Error+0xc0>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((response_r1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8000f80:	0244      	lsls	r4, r0, #9
 8000f82:	d4e1      	bmi.n	8000f48 <SD_CmdResp1Error+0x34>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8000f84:	0281      	lsls	r1, r0, #10
 8000f86:	d427      	bmi.n	8000fd8 <SD_CmdResp1Error+0xc4>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8000f88:	02c2      	lsls	r2, r0, #11
 8000f8a:	d427      	bmi.n	8000fdc <SD_CmdResp1Error+0xc8>
  {
    return(SD_CC_ERROR);
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8000f8c:	0303      	lsls	r3, r0, #12
 8000f8e:	d427      	bmi.n	8000fe0 <SD_CmdResp1Error+0xcc>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8000f90:	0346      	lsls	r6, r0, #13
 8000f92:	d427      	bmi.n	8000fe4 <SD_CmdResp1Error+0xd0>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8000f94:	0385      	lsls	r5, r0, #14
 8000f96:	d427      	bmi.n	8000fe8 <SD_CmdResp1Error+0xd4>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8000f98:	03c4      	lsls	r4, r0, #15
 8000f9a:	d427      	bmi.n	8000fec <SD_CmdResp1Error+0xd8>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8000f9c:	0401      	lsls	r1, r0, #16
 8000f9e:	d427      	bmi.n	8000ff0 <SD_CmdResp1Error+0xdc>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8000fa0:	0442      	lsls	r2, r0, #17
 8000fa2:	d427      	bmi.n	8000ff4 <SD_CmdResp1Error+0xe0>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8000fa4:	0483      	lsls	r3, r0, #18
 8000fa6:	d427      	bmi.n	8000ff8 <SD_CmdResp1Error+0xe4>
    return(SD_ERASE_RESET);
  }
  
  if((response_r1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
  {
    return(SD_AKE_SEQ_ERROR);
 8000fa8:	f010 0f08 	tst.w	r0, #8
 8000fac:	bf0c      	ite	eq
 8000fae:	2000      	moveq	r0, #0
 8000fb0:	201a      	movne	r0, #26
 8000fb2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  return errorstate;
 8000fb4:	4618      	mov	r0, r3
 8000fb6:	bd70      	pop	{r4, r5, r6, pc}
    return errorstate;
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8000fb8:	201c      	movs	r0, #28
 8000fba:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8000fbc:	2009      	movs	r0, #9
 8000fbe:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8000fc0:	200a      	movs	r0, #10
 8000fc2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8000fc4:	200b      	movs	r0, #11
 8000fc6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8000fc8:	200c      	movs	r0, #12
 8000fca:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8000fcc:	200d      	movs	r0, #13
 8000fce:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8000fd0:	200e      	movs	r0, #14
 8000fd2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8000fd4:	200f      	movs	r0, #15
 8000fd6:	bd70      	pop	{r4, r5, r6, pc}
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8000fd8:	2011      	movs	r0, #17
 8000fda:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8000fdc:	2012      	movs	r0, #18
 8000fde:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8000fe0:	2013      	movs	r0, #19
 8000fe2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8000fe4:	2014      	movs	r0, #20
 8000fe6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8000fe8:	2015      	movs	r0, #21
 8000fea:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8000fec:	2016      	movs	r0, #22
 8000fee:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8000ff0:	2017      	movs	r0, #23
 8000ff2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8000ff4:	2018      	movs	r0, #24
 8000ff6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8000ff8:	2019      	movs	r0, #25
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}
 8000ffa:	bd70      	pop	{r4, r5, r6, pc}
 8000ffc:	fdffe008 	.word	0xfdffe008

08001000 <SD_FindSCR>:
  * @param  hsd: SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8001000:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001002:	b08f      	sub	sp, #60	; 0x3c
  SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8001004:	2300      	movs	r3, #0
  * @param  hsd: SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8001006:	4605      	mov	r5, r0
  SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8001008:	9301      	str	r3, [sp, #4]
 800100a:	9302      	str	r3, [sp, #8]
  
  /* Set Block Size To 8 Bytes */
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 800100c:	2410      	movs	r4, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800100e:	2240      	movs	r2, #64	; 0x40
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001010:	9306      	str	r3, [sp, #24]
  * @param  hsd: SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8001012:	460e      	mov	r6, r1
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001014:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001018:	a903      	add	r1, sp, #12
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
  
  /* Set Block Size To 8 Bytes */
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
 800101a:	2708      	movs	r7, #8
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800101c:	6800      	ldr	r0, [r0, #0]
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
  
  /* Set Block Size To 8 Bytes */
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
 800101e:	9703      	str	r7, [sp, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8001020:	9404      	str	r4, [sp, #16]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001022:	9205      	str	r2, [sp, #20]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001024:	9307      	str	r3, [sp, #28]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001026:	f001 f839 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 800102a:	4621      	mov	r1, r4
 800102c:	4628      	mov	r0, r5
 800102e:	f7ff ff71 	bl	8000f14 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 8001032:	2800      	cmp	r0, #0
 8001034:	d161      	bne.n	80010fa <SD_FindSCR+0xfa>
  {
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
 8001036:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001038:	6828      	ldr	r0, [r5, #0]
  {
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
 800103a:	40a3      	lsls	r3, r4
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800103c:	a903      	add	r1, sp, #12
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800103e:	2437      	movs	r4, #55	; 0x37
  {
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
 8001040:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8001042:	9404      	str	r4, [sp, #16]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001044:	f001 f82a 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8001048:	4621      	mov	r1, r4
 800104a:	4628      	mov	r0, r5
 800104c:	f7ff ff62 	bl	8000f14 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 8001050:	4604      	mov	r4, r0
 8001052:	2800      	cmp	r0, #0
 8001054:	d151      	bne.n	80010fa <SD_FindSCR+0xfa>
  {
    return errorstate;
  }
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 8001056:	f04f 33ff 	mov.w	r3, #4294967295
 800105a:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.DataLength    = 8U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
 800105c:	2330      	movs	r3, #48	; 0x30
 800105e:	930a      	str	r3, [sp, #40]	; 0x28
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8001060:	2302      	movs	r3, #2
 8001062:	930b      	str	r3, [sp, #44]	; 0x2c
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001064:	900c      	str	r0, [sp, #48]	; 0x30
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8001066:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8001068:	a908      	add	r1, sp, #32
 800106a:	6828      	ldr	r0, [r5, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 8U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 800106c:	930d      	str	r3, [sp, #52]	; 0x34
  if(errorstate != SD_OK)
  {
    return errorstate;
  }
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 8U;
 800106e:	9709      	str	r7, [sp, #36]	; 0x24
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8001070:	f001 f870 	bl	8002154 <SDIO_DataConfig>
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  sdio_cmdinitstructure.Argument         = 0U;
 8001074:	9403      	str	r4, [sp, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001076:	a903      	add	r1, sp, #12
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
 8001078:	2433      	movs	r4, #51	; 0x33
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800107a:	6828      	ldr	r0, [r5, #0]
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
 800107c:	9404      	str	r4, [sp, #16]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800107e:	f001 f80d 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_SEND_SCR);
 8001082:	4621      	mov	r1, r4
 8001084:	4628      	mov	r0, r5
 8001086:	f7ff ff45 	bl	8000f14 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 800108a:	2800      	cmp	r0, #0
 800108c:	d135      	bne.n	80010fa <SD_FindSCR+0xfa>
 800108e:	466c      	mov	r4, sp
  {
    return errorstate;
  }
#ifdef SDIO_STA_STBITERR  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8001090:	6828      	ldr	r0, [r5, #0]
 8001092:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8001094:	f240 632a 	movw	r3, #1578	; 0x62a
 8001098:	4013      	ands	r3, r2
 800109a:	b93b      	cbnz	r3, 80010ac <SD_FindSCR+0xac>
#else /* SDIO_STA_STBITERR not defined */
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
  {
    if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
 800109c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800109e:	029f      	lsls	r7, r3, #10
 80010a0:	d5f7      	bpl.n	8001092 <SD_FindSCR+0x92>
    {
      *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
 80010a2:	f000 ffeb 	bl	800207c <SDIO_ReadFIFO>
 80010a6:	f844 0f04 	str.w	r0, [r4, #4]!
 80010aa:	e7f1      	b.n	8001090 <SD_FindSCR+0x90>
      index++;
    }
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 80010ac:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80010ae:	0719      	lsls	r1, r3, #28
 80010b0:	d503      	bpl.n	80010ba <SD_FindSCR+0xba>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 80010b2:	2308      	movs	r3, #8
 80010b4:	6383      	str	r3, [r0, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 80010b6:	2004      	movs	r0, #4
 80010b8:	e01f      	b.n	80010fa <SD_FindSCR+0xfa>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 80010ba:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80010bc:	079a      	lsls	r2, r3, #30
 80010be:	d502      	bpl.n	80010c6 <SD_FindSCR+0xc6>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 80010c0:	2302      	movs	r3, #2
 80010c2:	6383      	str	r3, [r0, #56]	; 0x38
 80010c4:	e018      	b.n	80010f8 <SD_FindSCR+0xf8>
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 80010c6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80010c8:	069b      	lsls	r3, r3, #26
 80010ca:	d503      	bpl.n	80010d4 <SD_FindSCR+0xd4>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 80010cc:	2320      	movs	r3, #32
 80010ce:	6383      	str	r3, [r0, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 80010d0:	2006      	movs	r0, #6
 80010d2:	e012      	b.n	80010fa <SD_FindSCR+0xfa>
  }
#ifdef SDIO_STA_STBITERR
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 80010d4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80010d6:	f413 7300 	ands.w	r3, r3, #512	; 0x200
 80010da:	d004      	beq.n	80010e6 <SD_FindSCR+0xe6>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 80010dc:	f44f 7300 	mov.w	r3, #512	; 0x200
 80010e0:	6383      	str	r3, [r0, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 80010e2:	2007      	movs	r0, #7
 80010e4:	e009      	b.n	80010fa <SD_FindSCR+0xfa>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80010e6:	f240 52ff 	movw	r2, #1535	; 0x5ff
 80010ea:	6382      	str	r2, [r0, #56]	; 0x38
 80010ec:	9a01      	ldr	r2, [sp, #4]
 80010ee:	ba12      	rev	r2, r2
  
  *(pSCR + 1U) = ((tempscr[0U] & SD_0TO7BITS) << 24U)  | ((tempscr[0U] & SD_8TO15BITS) << 8U) |\
 80010f0:	6072      	str	r2, [r6, #4]
 80010f2:	9a02      	ldr	r2, [sp, #8]
 80010f4:	ba12      	rev	r2, r2
    ((tempscr[0U] & SD_16TO23BITS) >> 8U) | ((tempscr[0U] & SD_24TO31BITS) >> 24U);
  
  *(pSCR) = ((tempscr[1U] & SD_0TO7BITS) << 24U)  | ((tempscr[1U] & SD_8TO15BITS) << 8U) |\
 80010f6:	6032      	str	r2, [r6, #0]
    ((tempscr[1U] & SD_16TO23BITS) >> 8U) | ((tempscr[1U] & SD_24TO31BITS) >> 24U);
  
  return errorstate;
 80010f8:	4618      	mov	r0, r3
}
 80010fa:	b00f      	add	sp, #60	; 0x3c
 80010fc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080010fe <HAL_SD_Get_CardInfo>:
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t tmp = 0U;
  
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
 80010fe:	6a02      	ldr	r2, [r0, #32]
 8001100:	f881 2056 	strb.w	r2, [r1, #86]	; 0x56
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
 8001104:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001106:	f8a1 2054 	strh.w	r2, [r1, #84]	; 0x54
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
 800110a:	6a82      	ldr	r2, [r0, #40]	; 0x28
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 800110c:	4603      	mov	r3, r0
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
 800110e:	0f90      	lsrs	r0, r2, #30
 8001110:	7008      	strb	r0, [r1, #0]
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8001112:	f3c2 6083 	ubfx	r0, r2, #26, #4
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8001116:	f3c2 6201 	ubfx	r2, r2, #24, #2
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 800111a:	7048      	strb	r0, [r1, #1]
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 800111c:	708a      	strb	r2, [r1, #2]
  
  /* Byte 1 */
  tmp = (hsd->CSD[0U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.TAAC = (uint8_t)tmp;
 800111e:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 8001122:	70ca      	strb	r2, [r1, #3]
  
  /* Byte 2 */
  tmp = (hsd->CSD[0U] & 0x0000FF00U) >> 8U;
  pCardInfo->SD_csd.NSAC = (uint8_t)tmp;
 8001124:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 8001128:	710a      	strb	r2, [r1, #4]
  
  /* Byte 3 */
  tmp = hsd->CSD[0U] & 0x000000FFU;
  pCardInfo->SD_csd.MaxBusClkFrec = (uint8_t)tmp;
 800112a:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 800112e:	714a      	strb	r2, [r1, #5]
  
  /* Byte 4 */
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
 8001130:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
 8001132:	0e10      	lsrs	r0, r2, #24
 8001134:	0100      	lsls	r0, r0, #4
 8001136:	80c8      	strh	r0, [r1, #6]
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001138:	88c8      	ldrh	r0, [r1, #6]
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 800113a:	b5f0      	push	{r4, r5, r6, r7, lr}
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 800113c:	b280      	uxth	r0, r0
 800113e:	f3c2 5403 	ubfx	r4, r2, #20, #4
 8001142:	4320      	orrs	r0, r4
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8001144:	f3c2 4203 	ubfx	r2, r2, #16, #4
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001148:	80c8      	strh	r0, [r1, #6]
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 800114a:	720a      	strb	r2, [r1, #8]
  
  /* Byte 6 */
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
 800114c:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
  pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
 8001150:	09d0      	lsrs	r0, r2, #7
 8001152:	7248      	strb	r0, [r1, #9]
  pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
 8001154:	f3c2 1080 	ubfx	r0, r2, #6, #1
 8001158:	7288      	strb	r0, [r1, #10]
  pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
 800115a:	f3c2 1040 	ubfx	r0, r2, #5, #1
 800115e:	72c8      	strb	r0, [r1, #11]
  pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
 8001160:	f3c2 1000 	ubfx	r0, r2, #4, #1
 8001164:	7308      	strb	r0, [r1, #12]
  pCardInfo->SD_csd.Reserved2       = 0U; /*!< Reserved */
 8001166:	2000      	movs	r0, #0
 8001168:	7348      	strb	r0, [r1, #13]
  
  if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
 800116a:	6a1c      	ldr	r4, [r3, #32]
 800116c:	2c01      	cmp	r4, #1
 800116e:	d83c      	bhi.n	80011ea <HAL_SD_Get_CardInfo+0xec>
  {
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x03U) << 10U;
 8001170:	0292      	lsls	r2, r2, #10
 8001172:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8001176:	610a      	str	r2, [r1, #16]
    
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
 8001178:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800117a:	690c      	ldr	r4, [r1, #16]
 800117c:	0092      	lsls	r2, r2, #2
 800117e:	f402 727f 	and.w	r2, r2, #1020	; 0x3fc
 8001182:	4322      	orrs	r2, r4
 8001184:	610a      	str	r2, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 8001186:	690c      	ldr	r4, [r1, #16]
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8001188:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 800118a:	ea44 7492 	orr.w	r4, r4, r2, lsr #30
 800118e:	610c      	str	r4, [r1, #16]
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8001190:	f3c2 64c2 	ubfx	r4, r2, #27, #3
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8001194:	f3c2 6202 	ubfx	r2, r2, #24, #3
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8001198:	750c      	strb	r4, [r1, #20]
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 800119a:	754a      	strb	r2, [r1, #21]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
 800119c:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
 800119e:	b2d4      	uxtb	r4, r2
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 80011a0:	0052      	lsls	r2, r2, #1
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 80011a2:	0965      	lsrs	r5, r4, #5
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 80011a4:	f002 0206 	and.w	r2, r2, #6
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 80011a8:	f3c4 0482 	ubfx	r4, r4, #2, #3
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 80011ac:	758d      	strb	r5, [r1, #22]
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 80011ae:	75cc      	strb	r4, [r1, #23]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 80011b0:	760a      	strb	r2, [r1, #24]
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 80011b2:	7e0c      	ldrb	r4, [r1, #24]
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 80011b4:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 80011b8:	ea44 14d2 	orr.w	r4, r4, r2, lsr #7
 80011bc:	760c      	strb	r4, [r1, #24]
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 80011be:	690c      	ldr	r4, [r1, #16]
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
 80011c0:	f891 e018 	ldrb.w	lr, [r1, #24]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 80011c4:	1c66      	adds	r6, r4, #1
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 80011c6:	7a0c      	ldrb	r4, [r1, #8]
 80011c8:	2501      	movs	r5, #1
 80011ca:	fa05 f404 	lsl.w	r4, r5, r4
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 80011ce:	f10e 0e02 	add.w	lr, lr, #2
 80011d2:	fa05 fe0e 	lsl.w	lr, r5, lr
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 80011d6:	650c      	str	r4, [r1, #80]	; 0x50
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 80011d8:	fba6 4504 	umull	r4, r5, r6, r4
 80011dc:	fbae 6704 	umull	r6, r7, lr, r4
 80011e0:	fb0e 7705 	mla	r7, lr, r5, r7
 80011e4:	e9c1 6712 	strd	r6, r7, [r1, #72]	; 0x48
 80011e8:	e023      	b.n	8001232 <HAL_SD_Get_CardInfo+0x134>
  }
  else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 80011ea:	2c02      	cmp	r4, #2
 80011ec:	d120      	bne.n	8001230 <HAL_SD_Get_CardInfo+0x132>
  {
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x3FU) << 16U;
 80011ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80011f0:	0412      	lsls	r2, r2, #16
 80011f2:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 80011f6:	610a      	str	r2, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 80011f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    
    pCardInfo->SD_csd.DeviceSize |= (tmp << 8U);
 80011fa:	690c      	ldr	r4, [r1, #16]
 80011fc:	0e15      	lsrs	r5, r2, #24
 80011fe:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 8001202:	610c      	str	r4, [r1, #16]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
 8001204:	690c      	ldr	r4, [r1, #16]
 8001206:	f3c2 4507 	ubfx	r5, r2, #16, #8
 800120a:	432c      	orrs	r4, r5
 800120c:	610c      	str	r4, [r1, #16]
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 800120e:	690c      	ldr	r4, [r1, #16]
 8001210:	2500      	movs	r5, #0
 8001212:	3401      	adds	r4, #1
 8001214:	f145 0500 	adc.w	r5, r5, #0
 8001218:	04ed      	lsls	r5, r5, #19
 800121a:	ea45 3554 	orr.w	r5, r5, r4, lsr #13
 800121e:	04e4      	lsls	r4, r4, #19
 8001220:	648c      	str	r4, [r1, #72]	; 0x48
    pCardInfo->CardBlockSize = 512U;    
 8001222:	f44f 7400 	mov.w	r4, #512	; 0x200
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8001226:	f3c2 2207 	ubfx	r2, r2, #8, #8
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 800122a:	64cd      	str	r5, [r1, #76]	; 0x4c
    pCardInfo->CardBlockSize = 512U;    
 800122c:	650c      	str	r4, [r1, #80]	; 0x50
 800122e:	e000      	b.n	8001232 <HAL_SD_Get_CardInfo+0x134>
  }
  else
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
 8001230:	2029      	movs	r0, #41	; 0x29
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 8001232:	f3c2 1480 	ubfx	r4, r2, #6, #1
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 8001236:	0052      	lsls	r2, r2, #1
 8001238:	f002 027e 	and.w	r2, r2, #126	; 0x7e
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 800123c:	764c      	strb	r4, [r1, #25]
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 800123e:	768a      	strb	r2, [r1, #26]
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
 8001240:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8001242:	7e8d      	ldrb	r5, [r1, #26]
 8001244:	f3c2 14c0 	ubfx	r4, r2, #7, #1
 8001248:	432c      	orrs	r4, r5
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 800124a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 800124e:	768c      	strb	r4, [r1, #26]
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 8001250:	76ca      	strb	r2, [r1, #27]
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
 8001252:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
 8001254:	0fd4      	lsrs	r4, r2, #31
 8001256:	770c      	strb	r4, [r1, #28]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
 8001258:	f3c2 7441 	ubfx	r4, r2, #29, #2
 800125c:	774c      	strb	r4, [r1, #29]
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 800125e:	f3c2 6482 	ubfx	r4, r2, #26, #3
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 8001262:	0d92      	lsrs	r2, r2, #22
 8001264:	f002 020c 	and.w	r2, r2, #12
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 8001268:	778c      	strb	r4, [r1, #30]
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 800126a:	77ca      	strb	r2, [r1, #31]
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 800126c:	8eda      	ldrh	r2, [r3, #54]	; 0x36
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 800126e:	7fcd      	ldrb	r5, [r1, #31]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 8001270:	b2d4      	uxtb	r4, r2
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8001272:	ea45 1594 	orr.w	r5, r5, r4, lsr #6
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8001276:	f3c4 1440 	ubfx	r4, r4, #5, #1
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 800127a:	77cd      	strb	r5, [r1, #31]
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.Reserved3           = 0U;
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 800127c:	f002 0201 	and.w	r2, r2, #1
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8001280:	f881 4020 	strb.w	r4, [r1, #32]
  pCardInfo->SD_csd.Reserved3           = 0U;
 8001284:	2400      	movs	r4, #0
 8001286:	f881 4021 	strb.w	r4, [r1, #33]	; 0x21
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 800128a:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
 800128e:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8001290:	0a24      	lsrs	r4, r4, #8
 8001292:	b2e2      	uxtb	r2, r4
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
 8001294:	09d5      	lsrs	r5, r2, #7
 8001296:	f881 5023 	strb.w	r5, [r1, #35]	; 0x23
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
 800129a:	f3c2 1580 	ubfx	r5, r2, #6, #1
 800129e:	f881 5024 	strb.w	r5, [r1, #36]	; 0x24
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
 80012a2:	f3c2 1540 	ubfx	r5, r2, #5, #1
 80012a6:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 80012aa:	f004 0403 	and.w	r4, r4, #3
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 80012ae:	f3c2 1500 	ubfx	r5, r2, #4, #1
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 80012b2:	f3c2 0281 	ubfx	r2, r2, #2, #2
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 80012b6:	f881 5026 	strb.w	r5, [r1, #38]	; 0x26
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 80012ba:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 80012be:	f881 4028 	strb.w	r4, [r1, #40]	; 0x28
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 80012c2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  pCardInfo->SD_csd.Reserved4 = 1U;
 80012c4:	2401      	movs	r4, #1
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 80012c6:	f3c2 0246 	ubfx	r2, r2, #1, #7
 80012ca:	f881 2029 	strb.w	r2, [r1, #41]	; 0x29
  pCardInfo->SD_csd.Reserved4 = 1U;
 80012ce:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
  
  /* Byte 0 */
  tmp = (uint8_t)((hsd->CID[0U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ManufacturerID = tmp;
 80012d2:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
 80012d6:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
  
  /* Byte 1 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
 80012da:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  pCardInfo->SD_cid.OEM_AppliID = tmp << 8U;
 80012dc:	f3c2 4507 	ubfx	r5, r2, #16, #8
 80012e0:	022d      	lsls	r5, r5, #8
 80012e2:	85cd      	strh	r5, [r1, #46]	; 0x2e
  
  /* Byte 2 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.OEM_AppliID |= tmp;
 80012e4:	8dcd      	ldrh	r5, [r1, #46]	; 0x2e
 80012e6:	b2ae      	uxth	r6, r5
 80012e8:	f3c2 2507 	ubfx	r5, r2, #8, #8
 80012ec:	4335      	orrs	r5, r6
 80012ee:	0612      	lsls	r2, r2, #24
 80012f0:	85cd      	strh	r5, [r1, #46]	; 0x2e
  
  /* Byte 3 */
  tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName1 = tmp << 24U;
 80012f2:	630a      	str	r2, [r1, #48]	; 0x30
  
  /* Byte 4 */
  tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
 80012f4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  pCardInfo->SD_cid.ProdName1 |= tmp << 16U;
 80012f6:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 80012f8:	0e16      	lsrs	r6, r2, #24
 80012fa:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
 80012fe:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 5 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
 8001300:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 8001302:	0a15      	lsrs	r5, r2, #8
 8001304:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
 8001308:	4335      	orrs	r5, r6
 800130a:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 800130c:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 800130e:	f3c2 2607 	ubfx	r6, r2, #8, #8
 8001312:	4335      	orrs	r5, r6
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 8001314:	b2d2      	uxtb	r2, r2
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 8001316:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 8001318:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
  
  /* Byte 8 */
  tmp = (uint8_t)((hsd->CID[2U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdRev = tmp;
 800131c:	f893 2043 	ldrb.w	r2, [r3, #67]	; 0x43
 8001320:	f881 2035 	strb.w	r2, [r1, #53]	; 0x35
  
  /* Byte 9 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
 8001324:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001326:	0c15      	lsrs	r5, r2, #16
 8001328:	062d      	lsls	r5, r5, #24
  pCardInfo->SD_cid.ProdSN = tmp << 24U;
 800132a:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 10 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdSN |= tmp << 16U;
 800132c:	6b8e      	ldr	r6, [r1, #56]	; 0x38
 800132e:	0215      	lsls	r5, r2, #8
 8001330:	f405 057f 	and.w	r5, r5, #16711680	; 0xff0000
 8001334:	4335      	orrs	r5, r6
 8001336:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
 8001338:	6b8d      	ldr	r5, [r1, #56]	; 0x38
 800133a:	0212      	lsls	r2, r2, #8
 800133c:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8001340:	432a      	orrs	r2, r5
 8001342:	638a      	str	r2, [r1, #56]	; 0x38
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
 8001344:	6b8d      	ldr	r5, [r1, #56]	; 0x38
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
 8001346:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  pCardInfo->SD_cid.ProdSN |= tmp;
 8001348:	ea45 6512 	orr.w	r5, r5, r2, lsr #24
 800134c:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 800134e:	f891 503c 	ldrb.w	r5, [r1, #60]	; 0x3c
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
 8001352:	f3c2 4207 	ubfx	r2, r2, #16, #8
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8001356:	ea45 1512 	orr.w	r5, r5, r2, lsr #4
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 800135a:	0212      	lsls	r2, r2, #8
 800135c:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8001360:	f881 503c 	strb.w	r5, [r1, #60]	; 0x3c
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 8001364:	87ca      	strh	r2, [r1, #62]	; 0x3e
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
 8001366:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8001368:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
 800136a:	b295      	uxth	r5, r2
 800136c:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8001370:	432a      	orrs	r2, r5
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 8001372:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8001376:	87ca      	strh	r2, [r1, #62]	; 0x3e
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 8001378:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
  pCardInfo->SD_cid.Reserved2 = 1U;
 800137c:	f881 4041 	strb.w	r4, [r1, #65]	; 0x41
  
  return errorstate;
}
 8001380:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08001384 <HAL_SD_Init>:
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 8001384:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 8001388:	2500      	movs	r5, #0
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 800138a:	b091      	sub	sp, #68	; 0x44
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
 800138c:	7705      	strb	r5, [r0, #28]
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 800138e:	4604      	mov	r4, r0
 8001390:	460e      	mov	r6, r1
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 8001392:	f88d 5012 	strb.w	r5, [sp, #18]
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
 8001396:	f001 f8bd 	bl	8002514 <HAL_SD_MspInit>
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
 800139a:	2376      	movs	r3, #118	; 0x76
 800139c:	930f      	str	r3, [sp, #60]	; 0x3c
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
 800139e:	950d      	str	r5, [sp, #52]	; 0x34
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 80013a0:	950e      	str	r5, [sp, #56]	; 0x38
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 80013a2:	ab10      	add	r3, sp, #64	; 0x40
 80013a4:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 80013a8:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 80013ac:	950a      	str	r5, [sp, #40]	; 0x28
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 80013ae:	950b      	str	r5, [sp, #44]	; 0x2c
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 80013b0:	950c      	str	r5, [sp, #48]	; 0x30
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 80013b2:	4f9e      	ldr	r7, [pc, #632]	; (800162c <HAL_SD_Init+0x2a8>)
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 80013b4:	6820      	ldr	r0, [r4, #0]
 80013b6:	ab0a      	add	r3, sp, #40	; 0x28
 80013b8:	cb0e      	ldmia	r3, {r1, r2, r3}
 80013ba:	f000 fe05 	bl	8001fc8 <SDIO_Init>
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
 80013be:	f88d 5013 	strb.w	r5, [sp, #19]
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 80013c2:	6820      	ldr	r0, [r4, #0]
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 80013c4:	603d      	str	r5, [r7, #0]
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 80013c6:	f000 fe61 	bl	800208c <SDIO_PowerState_ON>
  
  /* 1ms: required power up waiting time before starting the SD initialization 
     sequence */
  HAL_Delay(1);
 80013ca:	2001      	movs	r0, #1
 80013cc:	f7fe ff74 	bl	80002b8 <HAL_Delay>
  
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
 80013d0:	2301      	movs	r3, #1
 80013d2:	603b      	str	r3, [r7, #0]
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013d4:	a905      	add	r1, sp, #20
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80013d6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013da:	6820      	ldr	r0, [r4, #0]
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80013dc:	9309      	str	r3, [sp, #36]	; 0x24
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
  
  /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
 80013de:	9505      	str	r5, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
 80013e0:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
 80013e2:	9507      	str	r5, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80013e4:	9508      	str	r5, [sp, #32]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013e6:	f000 fe59 	bl	800209c <SDIO_SendCommand>
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t timeout, tmp;
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 80013ea:	6820      	ldr	r0, [r4, #0]
 80013ec:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80013ee:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80013f2:	f3c3 13c0 	ubfx	r3, r3, #7, #1
    
  while((timeout > 0U) && (!tmp))
 80013f6:	2b00      	cmp	r3, #0
 80013f8:	f040 817e 	bne.w	80016f8 <HAL_SD_Init+0x374>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 80013fc:	6b43      	ldr	r3, [r0, #52]	; 0x34
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 80013fe:	3a01      	subs	r2, #1
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8001400:	f3c3 13c0 	ubfx	r3, r3, #7, #1
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 8001404:	d1f7      	bne.n	80013f6 <HAL_SD_Init+0x72>
  }
  
  if(timeout == 0U)
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
 8001406:	2303      	movs	r3, #3
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */
  errorstate = SD_CmdError(hsd);
 8001408:	f88d 3013 	strb.w	r3, [sp, #19]
  
  if(errorstate != SD_OK)
 800140c:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001410:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 8001414:	2b00      	cmp	r3, #0
 8001416:	f040 80a3 	bne.w	8001560 <HAL_SD_Init+0x1dc>
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
 800141a:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 800141e:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
 8001420:	2308      	movs	r3, #8
 8001422:	9306      	str	r3, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001424:	a905      	add	r1, sp, #20
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001426:	2340      	movs	r3, #64	; 0x40
 8001428:	9307      	str	r3, [sp, #28]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800142a:	f000 fe37 	bl	800209c <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
 800142e:	6820      	ldr	r0, [r4, #0]
 8001430:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001432:	f013 0f45 	tst.w	r3, #69	; 0x45
 8001436:	bf14      	ite	ne
 8001438:	2201      	movne	r2, #1
 800143a:	2200      	moveq	r2, #0
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
 800143c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
  
  while((!tmp) && (timeout > 0U))
 8001440:	b942      	cbnz	r2, 8001454 <HAL_SD_Init+0xd0>
 8001442:	b13b      	cbz	r3, 8001454 <HAL_SD_Init+0xd0>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT);
 8001444:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8001446:	f012 0f45 	tst.w	r2, #69	; 0x45
 800144a:	bf14      	ite	ne
 800144c:	2201      	movne	r2, #1
 800144e:	2200      	moveq	r2, #0
    timeout--;
 8001450:	3b01      	subs	r3, #1
 8001452:	e7f5      	b.n	8001440 <HAL_SD_Init+0xbc>
  }
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT); 
 8001454:	6b42      	ldr	r2, [r0, #52]	; 0x34
  
  if((timeout == 0U) || tmp)
 8001456:	b10b      	cbz	r3, 800145c <HAL_SD_Init+0xd8>
 8001458:	0757      	lsls	r7, r2, #29
 800145a:	d503      	bpl.n	8001464 <HAL_SD_Init+0xe0>
  {
    /* Card is not V2.0 compliant or card does not support the set voltage range */
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 800145c:	2304      	movs	r3, #4
 800145e:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001460:	2503      	movs	r5, #3
 8001462:	e005      	b.n	8001470 <HAL_SD_Init+0xec>
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDREND))
 8001464:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001466:	0659      	lsls	r1, r3, #25
  {
    /* Card is SD V2.0 compliant */
    errorstate = SD_OK;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CMDREND);
 8001468:	bf46      	itte	mi
 800146a:	2340      	movmi	r3, #64	; 0x40
 800146c:	6383      	strmi	r3, [r0, #56]	; 0x38
    
    return errorstate;
  }
  
  return errorstate;
 800146e:	2529      	movpl	r5, #41	; 0x29
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */ 
  errorstate = SD_CmdResp7Error(hsd);
 8001470:	f88d 5013 	strb.w	r5, [sp, #19]
  
  if (errorstate == SD_OK)
 8001474:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8001478:	2300      	movs	r3, #0
 800147a:	b922      	cbnz	r2, 8001486 <HAL_SD_Init+0x102>
  {
    /* SD Card 2.0 */
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
 800147c:	2201      	movs	r2, #1
 800147e:	6222      	str	r2, [r4, #32]
    sdtype        = SD_HIGH_CAPACITY;
 8001480:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8001484:	e000      	b.n	8001488 <HAL_SD_Init+0x104>
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
 8001486:	461d      	mov	r5, r3
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8001488:	2737      	movs	r7, #55	; 0x37
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800148a:	a905      	add	r1, sp, #20
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
 800148c:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800148e:	9706      	str	r7, [sp, #24]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001490:	f000 fe04 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8001494:	4639      	mov	r1, r7
 8001496:	4620      	mov	r0, r4
 8001498:	f7ff fd3c 	bl	8000f14 <SD_CmdResp1Error>
 800149c:	f88d 0013 	strb.w	r0, [sp, #19]
  
  /* If errorstate is Command Timeout, it is a MMC card */
  /* If errorstate is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  if(errorstate == SD_OK)
 80014a0:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80014a4:	f003 08ff 	and.w	r8, r3, #255	; 0xff
 80014a8:	2b00      	cmp	r3, #0
 80014aa:	d159      	bne.n	8001560 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 80014ac:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 80014b0:	46c1      	mov	r9, r8
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 80014b2:	f445 1580 	orr.w	r5, r5, #1048576	; 0x100000
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80014b6:	2737      	movs	r7, #55	; 0x37
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80014b8:	a905      	add	r1, sp, #20
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80014ba:	f04f 0b40 	mov.w	fp, #64	; 0x40
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80014be:	f44f 6a80 	mov.w	sl, #1024	; 0x400
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80014c2:	6820      	ldr	r0, [r4, #0]
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80014c4:	9706      	str	r7, [sp, #24]
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 80014c6:	f8cd 9014 	str.w	r9, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80014ca:	f8cd b01c 	str.w	fp, [sp, #28]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80014ce:	f8cd 9020 	str.w	r9, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80014d2:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80014d6:	f000 fde1 	bl	800209c <SDIO_SendCommand>
      
      /* Check for error conditions */
      errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80014da:	4639      	mov	r1, r7
 80014dc:	4620      	mov	r0, r4
 80014de:	f7ff fd19 	bl	8000f14 <SD_CmdResp1Error>
 80014e2:	f88d 0013 	strb.w	r0, [sp, #19]
      
      if(errorstate != SD_OK)
 80014e6:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80014ea:	f003 07ff 	and.w	r7, r3, #255	; 0xff
 80014ee:	2b00      	cmp	r3, #0
 80014f0:	d136      	bne.n	8001560 <HAL_SD_Init+0x1dc>
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 80014f2:	2329      	movs	r3, #41	; 0x29
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80014f4:	a905      	add	r1, sp, #20
 80014f6:	6820      	ldr	r0, [r4, #0]
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 80014f8:	9306      	str	r3, [sp, #24]
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 80014fa:	9505      	str	r5, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80014fc:	f8cd b01c 	str.w	fp, [sp, #28]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001500:	9708      	str	r7, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001502:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001506:	f000 fdc9 	bl	800209c <SDIO_SendCommand>
  */
static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 800150a:	6823      	ldr	r3, [r4, #0]
 800150c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800150e:	f012 0f45 	tst.w	r2, #69	; 0x45
 8001512:	d0fb      	beq.n	800150c <HAL_SD_Init+0x188>
  {
  }
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001514:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001516:	0752      	lsls	r2, r2, #29
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001518:	bf45      	ittet	mi
 800151a:	2204      	movmi	r2, #4
    
    return errorstate;
 800151c:	2703      	movmi	r7, #3
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800151e:	f240 52ff 	movwpl	r2, #1535	; 0x5ff
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001522:	639a      	strmi	r2, [r3, #56]	; 0x38
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001524:	bf58      	it	pl
 8001526:	639a      	strpl	r2, [r3, #56]	; 0x38
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
      
      /* Check for error conditions */
      errorstate = SD_CmdResp3Error(hsd);
 8001528:	f88d 7013 	strb.w	r7, [sp, #19]
      
      if(errorstate != SD_OK)
 800152c:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001530:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8001534:	b9a3      	cbnz	r3, 8001560 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Get command response */
      response = SDIO_GetResponse(SDIO_RESP1);
 8001536:	f000 fdf5 	bl	8002124 <SDIO_GetResponse>
     or SD card 1.x */
  if(errorstate == SD_OK)
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 800153a:	2800      	cmp	r0, #0
      response = SDIO_GetResponse(SDIO_RESP1);
      
      /* Get operating voltage*/
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
      
      count++;
 800153c:	f108 0801 	add.w	r8, r8, #1
 8001540:	f64f 73ff 	movw	r3, #65535	; 0xffff
     or SD card 1.x */
  if(errorstate == SD_OK)
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 8001544:	db02      	blt.n	800154c <HAL_SD_Init+0x1c8>
 8001546:	4598      	cmp	r8, r3
 8001548:	d1b5      	bne.n	80014b6 <HAL_SD_Init+0x132>
 800154a:	e001      	b.n	8001550 <HAL_SD_Init+0x1cc>
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
      
      count++;
    }
    
    if(count >= SD_MAX_VOLT_TRIAL)
 800154c:	4598      	cmp	r8, r3
 800154e:	d103      	bne.n	8001558 <HAL_SD_Init+0x1d4>
    {
      errorstate = SD_INVALID_VOLTRANGE;
 8001550:	231b      	movs	r3, #27
 8001552:	f88d 3013 	strb.w	r3, [sp, #19]
 8001556:	e003      	b.n	8001560 <HAL_SD_Init+0x1dc>
      
      return errorstate;
    }
    
    if((response & SD_HIGH_CAPACITY) == SD_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8001558:	0043      	lsls	r3, r0, #1
    {
      hsd->CardType = HIGH_CAPACITY_SD_CARD;
 800155a:	bf44      	itt	mi
 800155c:	2302      	movmi	r3, #2
 800155e:	6223      	strmi	r3, [r4, #32]
    }
    
  } /* else MMC Card */
  
  return errorstate;
 8001560:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001564:	b2db      	uxtb	r3, r3
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
  
  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd); 
 8001566:	f88d 3012 	strb.w	r3, [sp, #18]
  
  if(errorstate != SD_OK)     
 800156a:	f89d 3012 	ldrb.w	r3, [sp, #18]
 800156e:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 8001572:	2b00      	cmp	r3, #0
 8001574:	f040 80ba 	bne.w	80016ec <HAL_SD_Init+0x368>
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
 8001578:	6820      	ldr	r0, [r4, #0]
 800157a:	f000 fd8b 	bl	8002094 <SDIO_GetPowerState>
 800157e:	2800      	cmp	r0, #0
 8001580:	f000 8080 	beq.w	8001684 <HAL_SD_Init+0x300>
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
 8001584:	6a23      	ldr	r3, [r4, #32]
 8001586:	2b04      	cmp	r3, #4
 8001588:	d020      	beq.n	80015cc <HAL_SD_Init+0x248>
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
 800158a:	2302      	movs	r3, #2
 800158c:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 800158e:	23c0      	movs	r3, #192	; 0xc0
 8001590:	9307      	str	r3, [sp, #28]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001592:	a905      	add	r1, sp, #20
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001594:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001598:	6820      	ldr	r0, [r4, #0]
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
 800159a:	9505      	str	r5, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 800159c:	9508      	str	r5, [sp, #32]
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800159e:	9309      	str	r3, [sp, #36]	; 0x24
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80015a0:	f000 fd7c 	bl	800209c <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 80015a4:	4620      	mov	r0, r4
 80015a6:	f7ff fbfd 	bl	8000da4 <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 80015aa:	2800      	cmp	r0, #0
 80015ac:	d16c      	bne.n	8001688 <HAL_SD_Init+0x304>
    {
      return errorstate;
    }
    
    /* Get Card identification number data */
    hsd->CID[0U] = SDIO_GetResponse(SDIO_RESP1);
 80015ae:	f000 fdb9 	bl	8002124 <SDIO_GetResponse>
 80015b2:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->CID[1U] = SDIO_GetResponse(SDIO_RESP2);
 80015b4:	2004      	movs	r0, #4
 80015b6:	f000 fdb5 	bl	8002124 <SDIO_GetResponse>
 80015ba:	63e0      	str	r0, [r4, #60]	; 0x3c
    hsd->CID[2U] = SDIO_GetResponse(SDIO_RESP3);
 80015bc:	2008      	movs	r0, #8
 80015be:	f000 fdb1 	bl	8002124 <SDIO_GetResponse>
 80015c2:	6420      	str	r0, [r4, #64]	; 0x40
    hsd->CID[3U] = SDIO_GetResponse(SDIO_RESP4);
 80015c4:	200c      	movs	r0, #12
 80015c6:	f000 fdad 	bl	8002124 <SDIO_GetResponse>
 80015ca:	6460      	str	r0, [r4, #68]	; 0x44
  }
  
  if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 80015cc:	6a23      	ldr	r3, [r4, #32]
 80015ce:	2b02      	cmp	r3, #2
 80015d0:	d901      	bls.n	80015d6 <HAL_SD_Init+0x252>
 80015d2:	2b06      	cmp	r3, #6
 80015d4:	d132      	bne.n	800163c <HAL_SD_Init+0x2b8>
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
 80015d6:	2303      	movs	r3, #3
 80015d8:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80015da:	a905      	add	r1, sp, #20
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80015dc:	2340      	movs	r3, #64	; 0x40
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80015de:	6820      	ldr	r0, [r4, #0]
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80015e0:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80015e2:	f000 fd5b 	bl	800209c <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 80015e6:	6820      	ldr	r0, [r4, #0]
 80015e8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80015ea:	f013 0f45 	tst.w	r3, #69	; 0x45
 80015ee:	d0fb      	beq.n	80015e8 <HAL_SD_Init+0x264>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 80015f0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80015f2:	075f      	lsls	r7, r3, #29
 80015f4:	d503      	bpl.n	80015fe <HAL_SD_Init+0x27a>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 80015f6:	2304      	movs	r3, #4
 80015f8:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 80015fa:	2503      	movs	r5, #3
 80015fc:	e045      	b.n	800168a <HAL_SD_Init+0x306>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 80015fe:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001600:	f013 0701 	ands.w	r7, r3, #1
 8001604:	d002      	beq.n	800160c <HAL_SD_Init+0x288>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001606:	2501      	movs	r5, #1
 8001608:	6385      	str	r5, [r0, #56]	; 0x38
 800160a:	e03e      	b.n	800168a <HAL_SD_Init+0x306>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 800160c:	f000 fd86 	bl	800211c <SDIO_GetCommandResponse>
 8001610:	2803      	cmp	r0, #3
 8001612:	d176      	bne.n	8001702 <HAL_SD_Init+0x37e>
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001614:	6823      	ldr	r3, [r4, #0]
 8001616:	f240 52ff 	movw	r2, #1535	; 0x5ff
 800161a:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it.  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 800161c:	4638      	mov	r0, r7
 800161e:	f000 fd81 	bl	8002124 <SDIO_GetResponse>
  
  if((response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)) == SD_ALLZERO)
 8001622:	f410 4f60 	tst.w	r0, #57344	; 0xe000
 8001626:	d103      	bne.n	8001630 <HAL_SD_Init+0x2ac>
  {
    *pRCA = (uint16_t) (response_r1 >> 16U);
 8001628:	0c00      	lsrs	r0, r0, #16
 800162a:	e008      	b.n	800163e <HAL_SD_Init+0x2ba>
 800162c:	422580a0 	.word	0x422580a0
    
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
 8001630:	0481      	lsls	r1, r0, #18
 8001632:	d468      	bmi.n	8001706 <HAL_SD_Init+0x382>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_R6_ILLEGAL_CMD) == SD_R6_ILLEGAL_CMD)
 8001634:	0442      	lsls	r2, r0, #17
 8001636:	d464      	bmi.n	8001702 <HAL_SD_Init+0x37e>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
 8001638:	0403      	lsls	r3, r0, #16
 800163a:	d466      	bmi.n	800170a <HAL_SD_Init+0x386>
  */
static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
 800163c:	2001      	movs	r0, #1
    {
      return errorstate;
    }
  }
  
  if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
 800163e:	6a23      	ldr	r3, [r4, #32]
 8001640:	2b04      	cmp	r3, #4
 8001642:	d022      	beq.n	800168a <HAL_SD_Init+0x306>
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
 8001644:	6260      	str	r0, [r4, #36]	; 0x24
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 8001646:	2309      	movs	r3, #9
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001648:	0400      	lsls	r0, r0, #16
 800164a:	9005      	str	r0, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 800164c:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800164e:	a905      	add	r1, sp, #20
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8001650:	23c0      	movs	r3, #192	; 0xc0
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001652:	6820      	ldr	r0, [r4, #0]
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8001654:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001656:	f000 fd21 	bl	800209c <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 800165a:	4620      	mov	r0, r4
 800165c:	f7ff fba2 	bl	8000da4 <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 8001660:	4605      	mov	r5, r0
 8001662:	b990      	cbnz	r0, 800168a <HAL_SD_Init+0x306>
    {
      return errorstate;
    }
    
    /* Get Card Specific Data */
    hsd->CSD[0U] = SDIO_GetResponse(SDIO_RESP1);
 8001664:	f000 fd5e 	bl	8002124 <SDIO_GetResponse>
 8001668:	62a0      	str	r0, [r4, #40]	; 0x28
    hsd->CSD[1U] = SDIO_GetResponse(SDIO_RESP2);
 800166a:	2004      	movs	r0, #4
 800166c:	f000 fd5a 	bl	8002124 <SDIO_GetResponse>
 8001670:	62e0      	str	r0, [r4, #44]	; 0x2c
    hsd->CSD[2U] = SDIO_GetResponse(SDIO_RESP3);
 8001672:	2008      	movs	r0, #8
 8001674:	f000 fd56 	bl	8002124 <SDIO_GetResponse>
 8001678:	6320      	str	r0, [r4, #48]	; 0x30
    hsd->CSD[3U] = SDIO_GetResponse(SDIO_RESP4);
 800167a:	200c      	movs	r0, #12
 800167c:	f000 fd52 	bl	8002124 <SDIO_GetResponse>
 8001680:	6360      	str	r0, [r4, #52]	; 0x34
 8001682:	e002      	b.n	800168a <HAL_SD_Init+0x306>
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
 8001684:	2525      	movs	r5, #37	; 0x25
 8001686:	e000      	b.n	800168a <HAL_SD_Init+0x306>
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
    
    if(errorstate != SD_OK)
 8001688:	4605      	mov	r5, r0
  {
    return errorstate;
  }
  
  /* Initialize the present SDIO card(s) and put them in idle state */
  errorstate = SD_Initialize_Cards(hsd);
 800168a:	f88d 5012 	strb.w	r5, [sp, #18]
  
  if (errorstate != SD_OK)
 800168e:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8001692:	bb5b      	cbnz	r3, 80016ec <HAL_SD_Init+0x368>
  {
    return errorstate;
  }
  
  /* Read CSD/CID MSD registers */
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
 8001694:	4631      	mov	r1, r6
 8001696:	4620      	mov	r0, r4
 8001698:	f7ff fd31 	bl	80010fe <HAL_SD_Get_CardInfo>
 800169c:	f88d 0012 	strb.w	r0, [sp, #18]
  
  if (errorstate == SD_OK)
 80016a0:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80016a4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80016a8:	b9ab      	cbnz	r3, 80016d6 <HAL_SD_Init+0x352>
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 80016aa:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80016ae:	6820      	ldr	r0, [r4, #0]
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80016b0:	9208      	str	r2, [sp, #32]
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 80016b2:	041b      	lsls	r3, r3, #16
 80016b4:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80016b6:	2340      	movs	r3, #64	; 0x40
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 80016b8:	2507      	movs	r5, #7
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80016ba:	9307      	str	r3, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80016bc:	a905      	add	r1, sp, #20
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80016be:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80016c2:	9309      	str	r3, [sp, #36]	; 0x24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 80016c4:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80016c6:	f000 fce9 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEL_DESEL_CARD);
 80016ca:	4629      	mov	r1, r5
 80016cc:	4620      	mov	r0, r4
 80016ce:	f7ff fc21 	bl	8000f14 <SD_CmdResp1Error>
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
  
  if (errorstate == SD_OK)
  {
    /* Select the Card */
    errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16U));
 80016d2:	f88d 0012 	strb.w	r0, [sp, #18]
  }
  
  /* Configure SDIO peripheral interface */
  SDIO_Init(hsd->Instance, hsd->Init);   
 80016d6:	f104 0310 	add.w	r3, r4, #16
 80016da:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80016de:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80016e2:	1d23      	adds	r3, r4, #4
 80016e4:	cb0e      	ldmia	r3, {r1, r2, r3}
 80016e6:	6820      	ldr	r0, [r4, #0]
 80016e8:	f000 fc6e 	bl	8001fc8 <SDIO_Init>
  
  return errorstate;
 80016ec:	f89d 0012 	ldrb.w	r0, [sp, #18]
 80016f0:	b2c0      	uxtb	r0, r0
}
 80016f2:	b011      	add	sp, #68	; 0x44
 80016f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80016f8:	f240 53ff 	movw	r3, #1535	; 0x5ff
 80016fc:	6383      	str	r3, [r0, #56]	; 0x38
  
  return errorstate;
 80016fe:	2300      	movs	r3, #0
 8001700:	e682      	b.n	8001408 <HAL_SD_Init+0x84>
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8001702:	2510      	movs	r5, #16
 8001704:	e7c1      	b.n	800168a <HAL_SD_Init+0x306>
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8001706:	2513      	movs	r5, #19
 8001708:	e7bf      	b.n	800168a <HAL_SD_Init+0x306>
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 800170a:	250f      	movs	r5, #15
 800170c:	e7bd      	b.n	800168a <HAL_SD_Init+0x306>
 800170e:	bf00      	nop

08001710 <HAL_SD_WideBusOperation_Config>:
  *            @arg SDIO_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 8001710:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  SDIO_InitTypeDef tmpinit;
  
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
 8001712:	6a03      	ldr	r3, [r0, #32]
 8001714:	2b03      	cmp	r3, #3
  *            @arg SDIO_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 8001716:	b08d      	sub	sp, #52	; 0x34
 8001718:	4605      	mov	r5, r0
 800171a:	460e      	mov	r6, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  SDIO_InitTypeDef tmpinit;
  
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
 800171c:	f000 8084 	beq.w	8001828 <HAL_SD_WideBusOperation_Config+0x118>
  {
    errorstate = SD_UNSUPPORTED_FEATURE;
    
    return errorstate;
  }
  else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 8001720:	2b02      	cmp	r3, #2
 8001722:	f200 8083 	bhi.w	800182c <HAL_SD_WideBusOperation_Config+0x11c>
    (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    if (WideMode == SDIO_BUS_WIDE_8B)
 8001726:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 800172a:	f000 8081 	beq.w	8001830 <HAL_SD_WideBusOperation_Config+0x120>
    {
      errorstate = SD_UNSUPPORTED_FEATURE;
    }
    else if (WideMode == SDIO_BUS_WIDE_4B)
 800172e:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8001732:	d129      	bne.n	8001788 <HAL_SD_WideBusOperation_Config+0x78>
static HAL_SD_ErrorTypedef SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  uint32_t scr[2U] = {0U, 0U};
 8001734:	2000      	movs	r0, #0
 8001736:	9004      	str	r0, [sp, #16]
 8001738:	9005      	str	r0, [sp, #20]
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 800173a:	f000 fcf3 	bl	8002124 <SDIO_GetResponse>
 800173e:	0180      	lsls	r0, r0, #6
 8001740:	d46e      	bmi.n	8001820 <HAL_SD_WideBusOperation_Config+0x110>
    
    return errorstate;
  }
  
  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 8001742:	a904      	add	r1, sp, #16
 8001744:	4628      	mov	r0, r5
 8001746:	f7ff fc5b 	bl	8001000 <SD_FindSCR>
  
  if(errorstate != SD_OK)
 800174a:	4604      	mov	r4, r0
 800174c:	2800      	cmp	r0, #0
 800174e:	d172      	bne.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
  {
    return errorstate;
  }
  
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
 8001750:	9b05      	ldr	r3, [sp, #20]
 8001752:	0359      	lsls	r1, r3, #13
 8001754:	d566      	bpl.n	8001824 <HAL_SD_WideBusOperation_Config+0x114>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001756:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001758:	9009      	str	r0, [sp, #36]	; 0x24
  
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 800175a:	041b      	lsls	r3, r3, #16
 800175c:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800175e:	2340      	movs	r3, #64	; 0x40
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8001760:	2737      	movs	r7, #55	; 0x37
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001762:	9308      	str	r3, [sp, #32]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001764:	a906      	add	r1, sp, #24
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001766:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800176a:	6828      	ldr	r0, [r5, #0]
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800176c:	930a      	str	r3, [sp, #40]	; 0x28
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800176e:	9707      	str	r7, [sp, #28]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001770:	f000 fc94 	bl	800209c <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8001774:	4639      	mov	r1, r7
 8001776:	4628      	mov	r0, r5
 8001778:	f7ff fbcc 	bl	8000f14 <SD_CmdResp1Error>
    
    if(errorstate != SD_OK)
 800177c:	4604      	mov	r4, r0
 800177e:	2800      	cmp	r0, #0
 8001780:	d159      	bne.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
    {
      return errorstate;
    }
    
    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    sdio_cmdinitstructure.Argument         = 2U;
 8001782:	2302      	movs	r3, #2
 8001784:	9306      	str	r3, [sp, #24]
 8001786:	e029      	b.n	80017dc <HAL_SD_WideBusOperation_Config+0xcc>
    }
    else if (WideMode == SDIO_BUS_WIDE_4B)
    {
      errorstate = SD_WideBus_Enable(hsd);
    }
    else if (WideMode == SDIO_BUS_WIDE_1B)
 8001788:	2900      	cmp	r1, #0
 800178a:	d153      	bne.n	8001834 <HAL_SD_WideBusOperation_Config+0x124>
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  uint32_t scr[2U] = {0U, 0U};
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 800178c:	4608      	mov	r0, r1
static HAL_SD_ErrorTypedef SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  uint32_t scr[2U] = {0U, 0U};
 800178e:	9104      	str	r1, [sp, #16]
 8001790:	9105      	str	r1, [sp, #20]
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 8001792:	f000 fcc7 	bl	8002124 <SDIO_GetResponse>
 8001796:	0182      	lsls	r2, r0, #6
 8001798:	d442      	bmi.n	8001820 <HAL_SD_WideBusOperation_Config+0x110>
    
    return errorstate;
  }
  
  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 800179a:	a904      	add	r1, sp, #16
 800179c:	4628      	mov	r0, r5
 800179e:	f7ff fc2f 	bl	8001000 <SD_FindSCR>
  
  if(errorstate != SD_OK)
 80017a2:	4604      	mov	r4, r0
 80017a4:	2800      	cmp	r0, #0
 80017a6:	d146      	bne.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
  {
    return errorstate;
  }
  
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
 80017a8:	9b05      	ldr	r3, [sp, #20]
 80017aa:	03db      	lsls	r3, r3, #15
 80017ac:	d53a      	bpl.n	8001824 <HAL_SD_WideBusOperation_Config+0x114>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80017ae:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80017b0:	9009      	str	r0, [sp, #36]	; 0x24
  
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80017b2:	041b      	lsls	r3, r3, #16
 80017b4:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80017b6:	2340      	movs	r3, #64	; 0x40
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80017b8:	2737      	movs	r7, #55	; 0x37
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80017ba:	9308      	str	r3, [sp, #32]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017bc:	a906      	add	r1, sp, #24
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80017be:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017c2:	6828      	ldr	r0, [r5, #0]
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80017c4:	930a      	str	r3, [sp, #40]	; 0x28
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80017c6:	9707      	str	r7, [sp, #28]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017c8:	f000 fc68 	bl	800209c <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80017cc:	4639      	mov	r1, r7
 80017ce:	4628      	mov	r0, r5
 80017d0:	f7ff fba0 	bl	8000f14 <SD_CmdResp1Error>
    
    if(errorstate != SD_OK)
 80017d4:	4604      	mov	r4, r0
 80017d6:	2800      	cmp	r0, #0
 80017d8:	d12d      	bne.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
    {
      return errorstate;
    }
    
    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    sdio_cmdinitstructure.Argument         = 0U;
 80017da:	9006      	str	r0, [sp, #24]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
 80017dc:	2406      	movs	r4, #6
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017de:	a906      	add	r1, sp, #24
 80017e0:	6828      	ldr	r0, [r5, #0]
      return errorstate;
    }
    
    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
 80017e2:	9407      	str	r4, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017e4:	f000 fc5a 	bl	800209c <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
 80017e8:	4621      	mov	r1, r4
 80017ea:	4628      	mov	r0, r5
 80017ec:	f7ff fb92 	bl	8000f14 <SD_CmdResp1Error>
 80017f0:	4604      	mov	r4, r0
    {
      /* WideMode is not a valid argument*/
      errorstate = SD_INVALID_PARAMETER;
    }
      
    if (errorstate == SD_OK)
 80017f2:	bb00      	cbnz	r0, 8001836 <HAL_SD_WideBusOperation_Config+0x126>
    {
      /* Configure the SDIO peripheral */
      tmpinit.ClockEdge           = hsd->Init.ClockEdge;
 80017f4:	686b      	ldr	r3, [r5, #4]
 80017f6:	9306      	str	r3, [sp, #24]
      tmpinit.ClockBypass         = hsd->Init.ClockBypass;
 80017f8:	68ab      	ldr	r3, [r5, #8]
 80017fa:	9307      	str	r3, [sp, #28]
      tmpinit.ClockPowerSave      = hsd->Init.ClockPowerSave;
 80017fc:	68eb      	ldr	r3, [r5, #12]
 80017fe:	9308      	str	r3, [sp, #32]
      tmpinit.BusWide             = WideMode;
      tmpinit.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8001800:	696b      	ldr	r3, [r5, #20]
 8001802:	930a      	str	r3, [sp, #40]	; 0x28
      tmpinit.ClockDiv            = hsd->Init.ClockDiv;
 8001804:	69ab      	ldr	r3, [r5, #24]
 8001806:	930b      	str	r3, [sp, #44]	; 0x2c
    {
      /* Configure the SDIO peripheral */
      tmpinit.ClockEdge           = hsd->Init.ClockEdge;
      tmpinit.ClockBypass         = hsd->Init.ClockBypass;
      tmpinit.ClockPowerSave      = hsd->Init.ClockPowerSave;
      tmpinit.BusWide             = WideMode;
 8001808:	9609      	str	r6, [sp, #36]	; 0x24
      tmpinit.HardwareFlowControl = hsd->Init.HardwareFlowControl;
      tmpinit.ClockDiv            = hsd->Init.ClockDiv;
      SDIO_Init(hsd->Instance, tmpinit);
 800180a:	ab0c      	add	r3, sp, #48	; 0x30
 800180c:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 8001810:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8001814:	ab06      	add	r3, sp, #24
 8001816:	cb0e      	ldmia	r3, {r1, r2, r3}
 8001818:	6828      	ldr	r0, [r5, #0]
 800181a:	f000 fbd5 	bl	8001fc8 <SDIO_Init>
 800181e:	e00a      	b.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
  {
    errorstate = SD_LOCK_UNLOCK_FAILED;
    
    return errorstate;
 8001820:	240e      	movs	r4, #14
 8001822:	e008      	b.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
  }
  else
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
 8001824:	2425      	movs	r4, #37	; 0x25
 8001826:	e006      	b.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
  {
    errorstate = SD_UNSUPPORTED_FEATURE;
    
    return errorstate;
 8001828:	2027      	movs	r0, #39	; 0x27
 800182a:	e005      	b.n	8001838 <HAL_SD_WideBusOperation_Config+0x128>
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 800182c:	2000      	movs	r0, #0
 800182e:	e003      	b.n	8001838 <HAL_SD_WideBusOperation_Config+0x128>
  else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
    (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    if (WideMode == SDIO_BUS_WIDE_8B)
    {
      errorstate = SD_UNSUPPORTED_FEATURE;
 8001830:	2427      	movs	r4, #39	; 0x27
 8001832:	e000      	b.n	8001836 <HAL_SD_WideBusOperation_Config+0x126>
      errorstate = SD_WideBus_Disable(hsd);
    }
    else
    {
      /* WideMode is not a valid argument*/
      errorstate = SD_INVALID_PARAMETER;
 8001834:	2426      	movs	r4, #38	; 0x26
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
  {
    errorstate = SD_UNSUPPORTED_FEATURE;
    
    return errorstate;
 8001836:	4620      	mov	r0, r4
      SDIO_Init(hsd->Instance, tmpinit);
    }
  }
  
  return errorstate;
}
 8001838:	b00d      	add	sp, #52	; 0x34
 800183a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800183c <HAL_SD_StopTransfer>:
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 800183c:	b530      	push	{r4, r5, lr}
 800183e:	b087      	sub	sp, #28
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 8001840:	2300      	movs	r3, #0
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001842:	2240      	movs	r2, #64	; 0x40
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 8001844:	4604      	mov	r4, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 8001846:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 8001848:	250c      	movs	r5, #12
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 800184a:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800184c:	a901      	add	r1, sp, #4
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800184e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001852:	6800      	ldr	r0, [r0, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001854:	9203      	str	r2, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001856:	9305      	str	r3, [sp, #20]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 8001858:	9502      	str	r5, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800185a:	f000 fc1f 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_STOP_TRANSMISSION);
 800185e:	4629      	mov	r1, r5
 8001860:	4620      	mov	r0, r4
 8001862:	f7ff fb57 	bl	8000f14 <SD_CmdResp1Error>
  
  return errorstate;
}
 8001866:	b007      	add	sp, #28
 8001868:	bd30      	pop	{r4, r5, pc}

0800186a <HAL_SD_ReadBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800186a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800186e:	4604      	mov	r4, r0
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8001870:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8001872:	4617      	mov	r7, r2
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8001874:	2200      	movs	r2, #0
 8001876:	62c2      	str	r2, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001878:	6a22      	ldr	r2, [r4, #32]
 800187a:	2a02      	cmp	r2, #2
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800187c:	b08d      	sub	sp, #52	; 0x34
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
    ReadAddr /= 512U;
 800187e:	bf04      	itt	eq
 8001880:	0a7f      	lsreq	r7, r7, #9
 8001882:	ea47 57c3 	orreq.w	r7, r7, r3, lsl #23
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001886:	f04f 0340 	mov.w	r3, #64	; 0x40
 800188a:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 800188c:	f04f 0300 	mov.w	r3, #0
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8001890:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001894:	9304      	str	r3, [sp, #16]
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 8001896:	bf08      	it	eq
 8001898:	f44f 7800 	moveq.w	r8, #512	; 0x200
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 800189c:	2610      	movs	r6, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800189e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80018a2:	460d      	mov	r5, r1
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80018a4:	a901      	add	r1, sp, #4
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80018a6:	9602      	str	r6, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80018a8:	9305      	str	r3, [sp, #20]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80018aa:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    BlockSize = 512U;
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
 80018ae:	f8cd 8004 	str.w	r8, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80018b2:	f000 fbf3 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 80018b6:	4631      	mov	r1, r6
 80018b8:	4620      	mov	r0, r4
 80018ba:	f7ff fb2b 	bl	8000f14 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 80018be:	4606      	mov	r6, r0
 80018c0:	2800      	cmp	r0, #0
 80018c2:	f040 8090 	bne.w	80019e6 <HAL_SD_ReadBlocks+0x17c>
  {
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 80018c6:	f04f 33ff 	mov.w	r3, #4294967295
 80018ca:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 80018cc:	fb09 f308 	mul.w	r3, r9, r8
 80018d0:	9307      	str	r3, [sp, #28]
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
 80018d2:	2390      	movs	r3, #144	; 0x90
 80018d4:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 80018d6:	2302      	movs	r3, #2
 80018d8:	9309      	str	r3, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 80018da:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80018dc:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80018de:	a906      	add	r1, sp, #24
 80018e0:	6820      	ldr	r0, [r4, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80018e2:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80018e4:	f000 fc36 	bl	8002154 <SDIO_DataConfig>
  
  if(NumberOfBlocks > 1U)
 80018e8:	f1b9 0f01 	cmp.w	r9, #1
  {
    /* Send CMD18 READ_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
 80018ec:	bf8c      	ite	hi
 80018ee:	2312      	movhi	r3, #18
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 80018f0:	2311      	movls	r3, #17
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80018f2:	a901      	add	r1, sp, #4
 80018f4:	6820      	ldr	r0, [r4, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 80018f6:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
 80018f8:	9701      	str	r7, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80018fa:	f000 fbcf 	bl	800209c <SDIO_SendCommand>
  
  /* Read block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 80018fe:	f1b9 0f01 	cmp.w	r9, #1
 8001902:	d91a      	bls.n	800193a <HAL_SD_ReadBlocks+0xd0>
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
 8001904:	2112      	movs	r1, #18
 8001906:	4620      	mov	r0, r4
 8001908:	f7ff fb04 	bl	8000f14 <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 800190c:	2800      	cmp	r0, #0
 800190e:	d16b      	bne.n	80019e8 <HAL_SD_ReadBlocks+0x17e>
      return errorstate;
    }
    
    /* Poll on SDIO flags */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 8001910:	6822      	ldr	r2, [r4, #0]
 8001912:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001914:	f240 332a 	movw	r3, #810	; 0x32a
 8001918:	400b      	ands	r3, r1
 800191a:	bb4b      	cbnz	r3, 8001970 <HAL_SD_ReadBlocks+0x106>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 800191c:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800191e:	0418      	lsls	r0, r3, #16
 8001920:	d5f7      	bpl.n	8001912 <HAL_SD_ReadBlocks+0xa8>
 8001922:	1f2f      	subs	r7, r5, #4
 8001924:	f105 081c 	add.w	r8, r5, #28
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 8001928:	6820      	ldr	r0, [r4, #0]
 800192a:	f000 fba7 	bl	800207c <SDIO_ReadFIFO>
 800192e:	f847 0f04 	str.w	r0, [r7, #4]!
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 8001932:	45b8      	cmp	r8, r7
 8001934:	d1f8      	bne.n	8001928 <HAL_SD_ReadBlocks+0xbe>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 8001936:	3520      	adds	r5, #32
 8001938:	e7ea      	b.n	8001910 <HAL_SD_ReadBlocks+0xa6>
    }      
  }
  else
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK); 
 800193a:	2111      	movs	r1, #17
 800193c:	4620      	mov	r0, r4
 800193e:	f7ff fae9 	bl	8000f14 <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 8001942:	2800      	cmp	r0, #0
 8001944:	d150      	bne.n	80019e8 <HAL_SD_ReadBlocks+0x17e>
      return errorstate;
    }    
    
    /* In case of single block transfer, no need of stop transfer at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8001946:	6822      	ldr	r2, [r4, #0]
 8001948:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800194a:	f240 632a 	movw	r3, #1578	; 0x62a
 800194e:	400b      	ands	r3, r1
 8001950:	b973      	cbnz	r3, 8001970 <HAL_SD_ReadBlocks+0x106>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))      
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 8001952:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001954:	0419      	lsls	r1, r3, #16
 8001956:	d5f7      	bpl.n	8001948 <HAL_SD_ReadBlocks+0xde>
 8001958:	1f2f      	subs	r7, r5, #4
 800195a:	f105 081c 	add.w	r8, r5, #28
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 800195e:	6820      	ldr	r0, [r4, #0]
 8001960:	f000 fb8c 	bl	800207c <SDIO_ReadFIFO>
 8001964:	f847 0f04 	str.w	r0, [r7, #4]!
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 8001968:	45b8      	cmp	r8, r7
 800196a:	d1f8      	bne.n	800195e <HAL_SD_ReadBlocks+0xf4>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 800196c:	3520      	adds	r5, #32
 800196e:	e7ea      	b.n	8001946 <HAL_SD_ReadBlocks+0xdc>
      }
    }
  }
  
  /* Send stop transmission command in case of multiblock read */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8001970:	6823      	ldr	r3, [r4, #0]
 8001972:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001974:	05db      	lsls	r3, r3, #23
 8001976:	d509      	bpl.n	800198c <HAL_SD_ReadBlocks+0x122>
 8001978:	f1b9 0f01 	cmp.w	r9, #1
 800197c:	d906      	bls.n	800198c <HAL_SD_ReadBlocks+0x122>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) ||\
 800197e:	6a23      	ldr	r3, [r4, #32]
 8001980:	2b02      	cmp	r3, #2
 8001982:	d803      	bhi.n	800198c <HAL_SD_ReadBlocks+0x122>
      (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
        (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 8001984:	4620      	mov	r0, r4
 8001986:	f7ff ff59 	bl	800183c <HAL_SD_StopTransfer>
 800198a:	4606      	mov	r6, r0
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 800198c:	6823      	ldr	r3, [r4, #0]
 800198e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001990:	0717      	lsls	r7, r2, #28
 8001992:	d503      	bpl.n	800199c <HAL_SD_ReadBlocks+0x132>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8001994:	2208      	movs	r2, #8
 8001996:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 8001998:	2004      	movs	r0, #4
 800199a:	e025      	b.n	80019e8 <HAL_SD_ReadBlocks+0x17e>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 800199c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800199e:	0790      	lsls	r0, r2, #30
 80019a0:	d502      	bpl.n	80019a8 <HAL_SD_ReadBlocks+0x13e>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 80019a2:	2002      	movs	r0, #2
 80019a4:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 80019a6:	e01f      	b.n	80019e8 <HAL_SD_ReadBlocks+0x17e>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 80019a8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80019aa:	0691      	lsls	r1, r2, #26
 80019ac:	d503      	bpl.n	80019b6 <HAL_SD_ReadBlocks+0x14c>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 80019ae:	2220      	movs	r2, #32
 80019b0:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 80019b2:	2006      	movs	r0, #6
 80019b4:	e018      	b.n	80019e8 <HAL_SD_ReadBlocks+0x17e>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 80019b6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80019b8:	0592      	lsls	r2, r2, #22
 80019ba:	d402      	bmi.n	80019c2 <HAL_SD_ReadBlocks+0x158>
 80019bc:	f04f 37ff 	mov.w	r7, #4294967295
 80019c0:	e00a      	b.n	80019d8 <HAL_SD_ReadBlocks+0x16e>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 80019c2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80019c6:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 80019c8:	2007      	movs	r0, #7
 80019ca:	e00d      	b.n	80019e8 <HAL_SD_ReadBlocks+0x17e>
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80019cc:	b147      	cbz	r7, 80019e0 <HAL_SD_ReadBlocks+0x176>
  {
    *tempbuff = SDIO_ReadFIFO(hsd->Instance);
 80019ce:	f000 fb55 	bl	800207c <SDIO_ReadFIFO>
 80019d2:	f845 0b04 	str.w	r0, [r5], #4
    tempbuff++;
    count--;
 80019d6:	3f01      	subs	r7, #1
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80019d8:	6820      	ldr	r0, [r4, #0]
 80019da:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80019dc:	029b      	lsls	r3, r3, #10
 80019de:	d4f5      	bmi.n	80019cc <HAL_SD_ReadBlocks+0x162>
    tempbuff++;
    count--;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80019e0:	f240 53ff 	movw	r3, #1535	; 0x5ff
 80019e4:	6383      	str	r3, [r0, #56]	; 0x38
 80019e6:	4630      	mov	r0, r6
  
  return errorstate;
}
 80019e8:	b00d      	add	sp, #52	; 0x34
 80019ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080019ee <HAL_SD_WriteBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80019ee:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80019f2:	4605      	mov	r5, r0
 80019f4:	b08c      	sub	sp, #48	; 0x30
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 80019f6:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80019f8:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
 80019fc:	9f15      	ldr	r7, [sp, #84]	; 0x54
 80019fe:	4614      	mov	r4, r2
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
 8001a00:	2200      	movs	r2, #0
 8001a02:	f88d 2003 	strb.w	r2, [sp, #3]
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8001a06:	62c2      	str	r2, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001a08:	6a2a      	ldr	r2, [r5, #32]
 8001a0a:	2a02      	cmp	r2, #2
  {
    BlockSize = 512U;
    WriteAddr /= 512U;
 8001a0c:	bf04      	itt	eq
 8001a0e:	0a64      	lsreq	r4, r4, #9
 8001a10:	ea44 54c3 	orreq.w	r4, r4, r3, lsl #23
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001a14:	f04f 0340 	mov.w	r3, #64	; 0x40
 8001a18:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001a1a:	f04f 0300 	mov.w	r3, #0
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 8001a1e:	bf08      	it	eq
 8001a20:	f44f 7800 	moveq.w	r8, #512	; 0x200
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8001a24:	f04f 0910 	mov.w	r9, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001a28:	9304      	str	r3, [sp, #16]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8001a2a:	460e      	mov	r6, r1
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001a2c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001a30:	a901      	add	r1, sp, #4
    BlockSize = 512U;
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
 8001a32:	f8cd 8004 	str.w	r8, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8001a36:	f8cd 9008 	str.w	r9, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001a3a:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001a3c:	f000 fb2e 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 8001a40:	4649      	mov	r1, r9
 8001a42:	4628      	mov	r0, r5
 8001a44:	f7ff fa66 	bl	8000f14 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 8001a48:	2800      	cmp	r0, #0
 8001a4a:	f040 80c3 	bne.w	8001bd4 <HAL_SD_WriteBlocks+0x1e6>
  {
    return errorstate;
  }
  
  if(NumberOfBlocks > 1U)
 8001a4e:	2f01      	cmp	r7, #1
  {
    /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
 8001a50:	bf8c      	ite	hi
 8001a52:	2319      	movhi	r3, #25
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 8001a54:	2318      	movls	r3, #24
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001a56:	a901      	add	r1, sp, #4
 8001a58:	6828      	ldr	r0, [r5, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 8001a5a:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
 8001a5c:	9401      	str	r4, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001a5e:	f000 fb1d 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  if(NumberOfBlocks > 1U)
 8001a62:	2f01      	cmp	r7, #1
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
 8001a64:	bf8c      	ite	hi
 8001a66:	2119      	movhi	r1, #25
  }
  else
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
 8001a68:	2118      	movls	r1, #24
 8001a6a:	4628      	mov	r0, r5
 8001a6c:	f7ff fa52 	bl	8000f14 <SD_CmdResp1Error>
 8001a70:	4604      	mov	r4, r0
  }  
  
  if (errorstate != SD_OK)
 8001a72:	2800      	cmp	r0, #0
 8001a74:	f040 80ae 	bne.w	8001bd4 <HAL_SD_WriteBlocks+0x1e6>
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 8001a78:	f04f 33ff 	mov.w	r3, #4294967295
 8001a7c:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8001a7e:	2390      	movs	r3, #144	; 0x90
 8001a80:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 8001a82:	9009      	str	r0, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001a84:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8001a86:	2301      	movs	r3, #1
  {
    return errorstate;
  }
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
 8001a88:	fb07 f808 	mul.w	r8, r7, r8
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8001a8c:	a906      	add	r1, sp, #24
 8001a8e:	6828      	ldr	r0, [r5, #0]
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 8001a90:	f8cd 801c 	str.w	r8, [sp, #28]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8001a94:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8001a96:	f000 fb5d 	bl	8002154 <SDIO_DataConfig>
  
  /* Write block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 8001a9a:	2f01      	cmp	r7, #1
 8001a9c:	d940      	bls.n	8001b20 <HAL_SD_WriteBlocks+0x132>
  {
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 8001a9e:	682b      	ldr	r3, [r5, #0]
 8001aa0:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001aa2:	f240 321a 	movw	r2, #794	; 0x31a
 8001aa6:	400a      	ands	r2, r1
 8001aa8:	bb9a      	cbnz	r2, 8001b12 <HAL_SD_WriteBlocks+0x124>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */     
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 8001aaa:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001aac:	0449      	lsls	r1, r1, #17
 8001aae:	d5f7      	bpl.n	8001aa0 <HAL_SD_WriteBlocks+0xb2>
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 8001ab0:	ebc4 0308 	rsb	r3, r4, r8
 8001ab4:	2b1f      	cmp	r3, #31
 8001ab6:	d813      	bhi.n	8001ae0 <HAL_SD_WriteBlocks+0xf2>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 8001ab8:	f013 0f03 	tst.w	r3, #3
 8001abc:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8001ac0:	bf18      	it	ne
 8001ac2:	3301      	addne	r3, #1
 8001ac4:	ea4f 0983 	mov.w	r9, r3, lsl #2
 8001ac8:	eb06 0a09 	add.w	sl, r6, r9
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 8001acc:	4556      	cmp	r6, sl
 8001ace:	d005      	beq.n	8001adc <HAL_SD_WriteBlocks+0xee>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 8001ad0:	4631      	mov	r1, r6
 8001ad2:	6828      	ldr	r0, [r5, #0]
 8001ad4:	f000 fad5 	bl	8002082 <SDIO_WriteFIFO>
            tempbuff++;
 8001ad8:	3604      	adds	r6, #4
 8001ada:	e7f7      	b.n	8001acc <HAL_SD_WriteBlocks+0xde>
 8001adc:	444c      	add	r4, r9
 8001ade:	e00d      	b.n	8001afc <HAL_SD_WriteBlocks+0x10e>
 8001ae0:	4691      	mov	r9, r2
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 8001ae2:	eb06 0109 	add.w	r1, r6, r9
 8001ae6:	6828      	ldr	r0, [r5, #0]
 8001ae8:	f109 0904 	add.w	r9, r9, #4
 8001aec:	f000 fac9 	bl	8002082 <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 8001af0:	f1b9 0f20 	cmp.w	r9, #32
 8001af4:	d1f5      	bne.n	8001ae2 <HAL_SD_WriteBlocks+0xf4>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 8001af6:	f106 0a20 	add.w	sl, r6, #32
          bytestransferred += 32U;
 8001afa:	3420      	adds	r4, #32
 8001afc:	4656      	mov	r6, sl
 8001afe:	e7ce      	b.n	8001a9e <HAL_SD_WriteBlocks+0xb0>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 8001b00:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001b02:	0449      	lsls	r1, r1, #17
 8001b04:	d40e      	bmi.n	8001b24 <HAL_SD_WriteBlocks+0x136>
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8001b06:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001b08:	f240 621a 	movw	r2, #1562	; 0x61a
 8001b0c:	400a      	ands	r2, r1
 8001b0e:	2a00      	cmp	r2, #0
 8001b10:	d0f6      	beq.n	8001b00 <HAL_SD_WriteBlocks+0x112>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8001b12:	682b      	ldr	r3, [r5, #0]
 8001b14:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001b16:	05d8      	lsls	r0, r3, #23
 8001b18:	d429      	bmi.n	8001b6e <HAL_SD_WriteBlocks+0x180>
 8001b1a:	e030      	b.n	8001b7e <HAL_SD_WriteBlocks+0x190>
 8001b1c:	444c      	add	r4, r9
 8001b1e:	4656      	mov	r6, sl
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8001b20:	682b      	ldr	r3, [r5, #0]
 8001b22:	e7f0      	b.n	8001b06 <HAL_SD_WriteBlocks+0x118>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 8001b24:	ebc4 0308 	rsb	r3, r4, r8
 8001b28:	2b1f      	cmp	r3, #31
 8001b2a:	d811      	bhi.n	8001b50 <HAL_SD_WriteBlocks+0x162>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 8001b2c:	f013 0f03 	tst.w	r3, #3
 8001b30:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8001b34:	bf18      	it	ne
 8001b36:	3301      	addne	r3, #1
 8001b38:	ea4f 0983 	mov.w	r9, r3, lsl #2
 8001b3c:	eb06 0a09 	add.w	sl, r6, r9
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 8001b40:	4556      	cmp	r6, sl
 8001b42:	d0eb      	beq.n	8001b1c <HAL_SD_WriteBlocks+0x12e>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 8001b44:	4631      	mov	r1, r6
 8001b46:	6828      	ldr	r0, [r5, #0]
 8001b48:	f000 fa9b 	bl	8002082 <SDIO_WriteFIFO>
            tempbuff++; 
 8001b4c:	3604      	adds	r6, #4
 8001b4e:	e7f7      	b.n	8001b40 <HAL_SD_WriteBlocks+0x152>
 8001b50:	4691      	mov	r9, r2
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 8001b52:	eb06 0109 	add.w	r1, r6, r9
 8001b56:	6828      	ldr	r0, [r5, #0]
 8001b58:	f109 0904 	add.w	r9, r9, #4
 8001b5c:	f000 fa91 	bl	8002082 <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 8001b60:	f1b9 0f20 	cmp.w	r9, #32
 8001b64:	d1f5      	bne.n	8001b52 <HAL_SD_WriteBlocks+0x164>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 8001b66:	f106 0a20 	add.w	sl, r6, #32
          bytestransferred += 32U;
 8001b6a:	3420      	adds	r4, #32
 8001b6c:	e7d7      	b.n	8001b1e <HAL_SD_WriteBlocks+0x130>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8001b6e:	2f01      	cmp	r7, #1
 8001b70:	d905      	bls.n	8001b7e <HAL_SD_WriteBlocks+0x190>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 8001b72:	6a2b      	ldr	r3, [r5, #32]
 8001b74:	2b02      	cmp	r3, #2
 8001b76:	d802      	bhi.n	8001b7e <HAL_SD_WriteBlocks+0x190>
      (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 8001b78:	4628      	mov	r0, r5
 8001b7a:	f7ff fe5f 	bl	800183c <HAL_SD_StopTransfer>
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8001b7e:	682b      	ldr	r3, [r5, #0]
 8001b80:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001b82:	0714      	lsls	r4, r2, #28
 8001b84:	d503      	bpl.n	8001b8e <HAL_SD_WriteBlocks+0x1a0>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8001b86:	2208      	movs	r2, #8
 8001b88:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 8001b8a:	2004      	movs	r0, #4
 8001b8c:	e022      	b.n	8001bd4 <HAL_SD_WriteBlocks+0x1e6>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8001b8e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001b90:	0790      	lsls	r0, r2, #30
 8001b92:	d502      	bpl.n	8001b9a <HAL_SD_WriteBlocks+0x1ac>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8001b94:	2002      	movs	r0, #2
 8001b96:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 8001b98:	e01c      	b.n	8001bd4 <HAL_SD_WriteBlocks+0x1e6>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
 8001b9a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001b9c:	06d1      	lsls	r1, r2, #27
 8001b9e:	d503      	bpl.n	8001ba8 <HAL_SD_WriteBlocks+0x1ba>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 8001ba0:	2210      	movs	r2, #16
 8001ba2:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_TX_UNDERRUN;
    
    return errorstate;
 8001ba4:	2005      	movs	r0, #5
 8001ba6:	e015      	b.n	8001bd4 <HAL_SD_WriteBlocks+0x1e6>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 8001ba8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001baa:	0592      	lsls	r2, r2, #22
 8001bac:	d504      	bpl.n	8001bb8 <HAL_SD_WriteBlocks+0x1ca>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8001bae:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001bb2:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 8001bb4:	2007      	movs	r0, #7
 8001bb6:	e00d      	b.n	8001bd4 <HAL_SD_WriteBlocks+0x1e6>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001bb8:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001bbc:	639a      	str	r2, [r3, #56]	; 0x38
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
 8001bbe:	f10d 0103 	add.w	r1, sp, #3
 8001bc2:	4628      	mov	r0, r5
 8001bc4:	f7ff f904 	bl	8000dd0 <SD_IsCardProgramming>
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
  
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
 8001bc8:	b920      	cbnz	r0, 8001bd4 <HAL_SD_WriteBlocks+0x1e6>
 8001bca:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001bce:	3b06      	subs	r3, #6
 8001bd0:	2b01      	cmp	r3, #1
 8001bd2:	d9f4      	bls.n	8001bbe <HAL_SD_WriteBlocks+0x1d0>
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
  }
  
  return errorstate;
}
 8001bd4:	b00c      	add	sp, #48	; 0x30
 8001bd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08001bda <HAL_SD_GetStatus>:
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 8001bda:	b530      	push	{r4, r5, lr}
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001bdc:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 8001bde:	b087      	sub	sp, #28
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001be0:	041b      	lsls	r3, r3, #16
 8001be2:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001be4:	2340      	movs	r3, #64	; 0x40
 8001be6:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001be8:	2300      	movs	r3, #0
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 8001bea:	4604      	mov	r4, r0
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8001bec:	250d      	movs	r5, #13
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001bee:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001bf0:	a901      	add	r1, sp, #4
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001bf2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001bf6:	6800      	ldr	r0, [r0, #0]
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8001bf8:	9502      	str	r5, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001bfa:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001bfc:	f000 fa4e 	bl	800209c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEND_STATUS);
 8001c00:	4629      	mov	r1, r5
 8001c02:	4620      	mov	r0, r4
 8001c04:	f7ff f986 	bl	8000f14 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 8001c08:	b938      	cbnz	r0, 8001c1a <HAL_SD_GetStatus+0x40>
  {
    return errorstate;
  }
  
  /* Get SD card status */
  *pCardStatus = SDIO_GetResponse(SDIO_RESP1);
 8001c0a:	f000 fa8b 	bl	8002124 <SDIO_GetResponse>
  cardstate = SD_GetState(hsd);
  
  /* Find SD status according to card state*/
  if (cardstate == SD_CARD_TRANSFER)
  {
    return SD_TRANSFER_OK;
 8001c0e:	f3c0 2043 	ubfx	r0, r0, #9, #4
 8001c12:	3804      	subs	r0, #4
 8001c14:	bf18      	it	ne
 8001c16:	2001      	movne	r0, #1
 8001c18:	e000      	b.n	8001c1c <HAL_SD_GetStatus+0x42>
  }
  else if(cardstate == SD_CARD_ERROR)
  {
    return SD_TRANSFER_ERROR;
 8001c1a:	2002      	movs	r0, #2
  }
  else
  {
    return SD_TRANSFER_BUSY;
  }
}
 8001c1c:	b007      	add	sp, #28
 8001c1e:	bd30      	pop	{r4, r5, pc}

08001c20 <UART_SetConfig>:
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t tmpreg = 0x00U;
  
  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 8001c20:	6842      	ldr	r2, [r0, #4]
 8001c22:	4ba1      	ldr	r3, [pc, #644]	; (8001ea8 <UART_SetConfig+0x288>)
 8001c24:	429a      	cmp	r2, r3
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8001c26:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001c2a:	4604      	mov	r4, r0
  uint32_t tmpreg = 0x00U;
  
  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 8001c2c:	d904      	bls.n	8001c38 <UART_SetConfig+0x18>
 8001c2e:	f640 1184 	movw	r1, #2436	; 0x984
 8001c32:	489e      	ldr	r0, [pc, #632]	; (8001eac <UART_SetConfig+0x28c>)
 8001c34:	f000 fc5d 	bl	80024f2 <assert_failed>
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
 8001c38:	68e3      	ldr	r3, [r4, #12]
 8001c3a:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
 8001c3e:	d004      	beq.n	8001c4a <UART_SetConfig+0x2a>
 8001c40:	f640 1185 	movw	r1, #2437	; 0x985
 8001c44:	4899      	ldr	r0, [pc, #612]	; (8001eac <UART_SetConfig+0x28c>)
 8001c46:	f000 fc54 	bl	80024f2 <assert_failed>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
 8001c4a:	6923      	ldr	r3, [r4, #16]
 8001c4c:	f433 6280 	bics.w	r2, r3, #1024	; 0x400
 8001c50:	d007      	beq.n	8001c62 <UART_SetConfig+0x42>
 8001c52:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8001c56:	d004      	beq.n	8001c62 <UART_SetConfig+0x42>
 8001c58:	f640 1186 	movw	r1, #2438	; 0x986
 8001c5c:	4893      	ldr	r0, [pc, #588]	; (8001eac <UART_SetConfig+0x28c>)
 8001c5e:	f000 fc48 	bl	80024f2 <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
 8001c62:	6962      	ldr	r2, [r4, #20]
 8001c64:	f64f 73f3 	movw	r3, #65523	; 0xfff3
 8001c68:	4013      	ands	r3, r2
 8001c6a:	b903      	cbnz	r3, 8001c6e <UART_SetConfig+0x4e>
 8001c6c:	b922      	cbnz	r2, 8001c78 <UART_SetConfig+0x58>
 8001c6e:	f640 1187 	movw	r1, #2439	; 0x987
 8001c72:	488e      	ldr	r0, [pc, #568]	; (8001eac <UART_SetConfig+0x28c>)
 8001c74:	f000 fc3d 	bl	80024f2 <assert_failed>

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8001c78:	6827      	ldr	r7, [r4, #0]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001c7a:	68a1      	ldr	r1, [r4, #8]
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8001c7c:	693b      	ldr	r3, [r7, #16]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001c7e:	69e0      	ldr	r0, [r4, #28]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8001c80:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8001c84:	68e3      	ldr	r3, [r4, #12]
 8001c86:	4313      	orrs	r3, r2
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001c88:	6922      	ldr	r2, [r4, #16]

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
  
  /* Write to USART CR2 */
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 8001c8a:	613b      	str	r3, [r7, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 8001c8c:	68fb      	ldr	r3, [r7, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001c8e:	4311      	orrs	r1, r2
 8001c90:	6962      	ldr	r2, [r4, #20]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8001c92:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001c96:	430a      	orrs	r2, r1
 8001c98:	4302      	orrs	r2, r0

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8001c9a:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001c9e:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8001ca0:	60fb      	str	r3, [r7, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 8001ca2:	697b      	ldr	r3, [r7, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 8001ca4:	f423 7240 	bic.w	r2, r3, #768	; 0x300
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8001ca8:	69a3      	ldr	r3, [r4, #24]
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001caa:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8001cae:	ea43 0302 	orr.w	r3, r3, r2
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8001cb2:	617b      	str	r3, [r7, #20]
 8001cb4:	4b7e      	ldr	r3, [pc, #504]	; (8001eb0 <UART_SetConfig+0x290>)
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001cb6:	d17c      	bne.n	8001db2 <UART_SetConfig+0x192>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8001cb8:	429f      	cmp	r7, r3
 8001cba:	d003      	beq.n	8001cc4 <UART_SetConfig+0xa4>
 8001cbc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001cc0:	429f      	cmp	r7, r3
 8001cc2:	d131      	bne.n	8001d28 <UART_SetConfig+0x108>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8001cc4:	f7ff f856 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001cc8:	6863      	ldr	r3, [r4, #4]
 8001cca:	2519      	movs	r5, #25
 8001ccc:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8001cd0:	4368      	muls	r0, r5
 8001cd2:	fbb0 f8f8 	udiv	r8, r0, r8
 8001cd6:	f7ff f84d 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001cda:	6866      	ldr	r6, [r4, #4]
 8001cdc:	4368      	muls	r0, r5
 8001cde:	0076      	lsls	r6, r6, #1
 8001ce0:	fbb0 f6f6 	udiv	r6, r0, r6
 8001ce4:	f7ff f846 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001ce8:	6863      	ldr	r3, [r4, #4]
 8001cea:	f04f 0964 	mov.w	r9, #100	; 0x64
 8001cee:	005b      	lsls	r3, r3, #1
 8001cf0:	4368      	muls	r0, r5
 8001cf2:	fbb0 f0f3 	udiv	r0, r0, r3
 8001cf6:	fbb0 f0f9 	udiv	r0, r0, r9
 8001cfa:	fb09 6610 	mls	r6, r9, r0, r6
 8001cfe:	f7ff f839 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001d02:	fbb8 f8f9 	udiv	r8, r8, r9
 8001d06:	6861      	ldr	r1, [r4, #4]
 8001d08:	00f6      	lsls	r6, r6, #3
 8001d0a:	3632      	adds	r6, #50	; 0x32
 8001d0c:	fbb6 f6f9 	udiv	r6, r6, r9
 8001d10:	0076      	lsls	r6, r6, #1
 8001d12:	4368      	muls	r0, r5
 8001d14:	0049      	lsls	r1, r1, #1
 8001d16:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8001d1a:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8001d1e:	fbb0 faf1 	udiv	sl, r0, r1
 8001d22:	f7ff f827 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001d26:	e030      	b.n	8001d8a <UART_SetConfig+0x16a>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8001d28:	f7ff f80c 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001d2c:	6863      	ldr	r3, [r4, #4]
 8001d2e:	2519      	movs	r5, #25
 8001d30:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8001d34:	4368      	muls	r0, r5
 8001d36:	fbb0 f8f8 	udiv	r8, r0, r8
 8001d3a:	f7ff f803 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001d3e:	6866      	ldr	r6, [r4, #4]
 8001d40:	4368      	muls	r0, r5
 8001d42:	0076      	lsls	r6, r6, #1
 8001d44:	fbb0 f6f6 	udiv	r6, r0, r6
 8001d48:	f7fe fffc 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001d4c:	6863      	ldr	r3, [r4, #4]
 8001d4e:	f04f 0964 	mov.w	r9, #100	; 0x64
 8001d52:	005b      	lsls	r3, r3, #1
 8001d54:	4368      	muls	r0, r5
 8001d56:	fbb0 f0f3 	udiv	r0, r0, r3
 8001d5a:	fbb0 f0f9 	udiv	r0, r0, r9
 8001d5e:	fb09 6610 	mls	r6, r9, r0, r6
 8001d62:	f7fe ffef 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001d66:	fbb8 f8f9 	udiv	r8, r8, r9
 8001d6a:	00f6      	lsls	r6, r6, #3
 8001d6c:	6861      	ldr	r1, [r4, #4]
 8001d6e:	3632      	adds	r6, #50	; 0x32
 8001d70:	fbb6 f6f9 	udiv	r6, r6, r9
 8001d74:	0076      	lsls	r6, r6, #1
 8001d76:	4368      	muls	r0, r5
 8001d78:	0049      	lsls	r1, r1, #1
 8001d7a:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8001d7e:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8001d82:	fbb0 faf1 	udiv	sl, r0, r1
 8001d86:	f7fe ffdd 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001d8a:	4345      	muls	r5, r0
 8001d8c:	6860      	ldr	r0, [r4, #4]
 8001d8e:	0040      	lsls	r0, r0, #1
 8001d90:	fbb5 f0f0 	udiv	r0, r5, r0
 8001d94:	fbb0 f0f9 	udiv	r0, r0, r9
 8001d98:	fb09 a210 	mls	r2, r9, r0, sl
 8001d9c:	00d2      	lsls	r2, r2, #3
 8001d9e:	3232      	adds	r2, #50	; 0x32
 8001da0:	fbb2 f3f9 	udiv	r3, r2, r9
 8001da4:	f003 0307 	and.w	r3, r3, #7
 8001da8:	4443      	add	r3, r8
 8001daa:	441e      	add	r6, r3
 8001dac:	60be      	str	r6, [r7, #8]
 8001dae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8001db2:	429f      	cmp	r7, r3
 8001db4:	d002      	beq.n	8001dbc <UART_SetConfig+0x19c>
 8001db6:	4b3f      	ldr	r3, [pc, #252]	; (8001eb4 <UART_SetConfig+0x294>)
 8001db8:	429f      	cmp	r7, r3
 8001dba:	d130      	bne.n	8001e1e <UART_SetConfig+0x1fe>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8001dbc:	f7fe ffda 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001dc0:	6863      	ldr	r3, [r4, #4]
 8001dc2:	2519      	movs	r5, #25
 8001dc4:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8001dc8:	4368      	muls	r0, r5
 8001dca:	fbb0 f8f8 	udiv	r8, r0, r8
 8001dce:	f7fe ffd1 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001dd2:	6866      	ldr	r6, [r4, #4]
 8001dd4:	4368      	muls	r0, r5
 8001dd6:	00b6      	lsls	r6, r6, #2
 8001dd8:	fbb0 f6f6 	udiv	r6, r0, r6
 8001ddc:	f7fe ffca 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001de0:	6863      	ldr	r3, [r4, #4]
 8001de2:	f04f 0964 	mov.w	r9, #100	; 0x64
 8001de6:	009b      	lsls	r3, r3, #2
 8001de8:	4368      	muls	r0, r5
 8001dea:	fbb0 f0f3 	udiv	r0, r0, r3
 8001dee:	fbb0 f0f9 	udiv	r0, r0, r9
 8001df2:	fb09 6610 	mls	r6, r9, r0, r6
 8001df6:	f7fe ffbd 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001dfa:	fbb8 f8f9 	udiv	r8, r8, r9
 8001dfe:	6861      	ldr	r1, [r4, #4]
 8001e00:	0136      	lsls	r6, r6, #4
 8001e02:	4368      	muls	r0, r5
 8001e04:	0089      	lsls	r1, r1, #2
 8001e06:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8001e0a:	3632      	adds	r6, #50	; 0x32
 8001e0c:	fbb0 faf1 	udiv	sl, r0, r1
 8001e10:	fbb6 f6f9 	udiv	r6, r6, r9
 8001e14:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8001e18:	f7fe ffac 	bl	8000d74 <HAL_RCC_GetPCLK2Freq>
 8001e1c:	e02f      	b.n	8001e7e <UART_SetConfig+0x25e>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8001e1e:	f7fe ff91 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001e22:	6863      	ldr	r3, [r4, #4]
 8001e24:	2519      	movs	r5, #25
 8001e26:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8001e2a:	4368      	muls	r0, r5
 8001e2c:	fbb0 f8f8 	udiv	r8, r0, r8
 8001e30:	f7fe ff88 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001e34:	6866      	ldr	r6, [r4, #4]
 8001e36:	4368      	muls	r0, r5
 8001e38:	00b6      	lsls	r6, r6, #2
 8001e3a:	fbb0 f6f6 	udiv	r6, r0, r6
 8001e3e:	f7fe ff81 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001e42:	6863      	ldr	r3, [r4, #4]
 8001e44:	f04f 0964 	mov.w	r9, #100	; 0x64
 8001e48:	009b      	lsls	r3, r3, #2
 8001e4a:	4368      	muls	r0, r5
 8001e4c:	fbb0 f0f3 	udiv	r0, r0, r3
 8001e50:	fbb0 f0f9 	udiv	r0, r0, r9
 8001e54:	fb09 6610 	mls	r6, r9, r0, r6
 8001e58:	f7fe ff74 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001e5c:	fbb8 f8f9 	udiv	r8, r8, r9
 8001e60:	6861      	ldr	r1, [r4, #4]
 8001e62:	0136      	lsls	r6, r6, #4
 8001e64:	3632      	adds	r6, #50	; 0x32
 8001e66:	4368      	muls	r0, r5
 8001e68:	fbb6 f6f9 	udiv	r6, r6, r9
 8001e6c:	0089      	lsls	r1, r1, #2
 8001e6e:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8001e72:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8001e76:	fbb0 faf1 	udiv	sl, r0, r1
 8001e7a:	f7fe ff63 	bl	8000d44 <HAL_RCC_GetPCLK1Freq>
 8001e7e:	4345      	muls	r5, r0
 8001e80:	6860      	ldr	r0, [r4, #4]
 8001e82:	0080      	lsls	r0, r0, #2
 8001e84:	fbb5 f0f0 	udiv	r0, r5, r0
 8001e88:	fbb0 f0f9 	udiv	r0, r0, r9
 8001e8c:	fb09 a210 	mls	r2, r9, r0, sl
 8001e90:	0112      	lsls	r2, r2, #4
 8001e92:	3232      	adds	r2, #50	; 0x32
 8001e94:	fbb2 f3f9 	udiv	r3, r2, r9
 8001e98:	f003 030f 	and.w	r3, r3, #15
 8001e9c:	4433      	add	r3, r6
 8001e9e:	4443      	add	r3, r8
 8001ea0:	60bb      	str	r3, [r7, #8]
 8001ea2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001ea6:	bf00      	nop
 8001ea8:	00a037a0 	.word	0x00a037a0
 8001eac:	080027f4 	.word	0x080027f4
 8001eb0:	40011000 	.word	0x40011000
 8001eb4:	40011400 	.word	0x40011400

08001eb8 <HAL_UART_Init>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8001eb8:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 8001eba:	4604      	mov	r4, r0
 8001ebc:	2800      	cmp	r0, #0
 8001ebe:	d07b      	beq.n	8001fb8 <HAL_UART_Init+0x100>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
 8001ec0:	6981      	ldr	r1, [r0, #24]
 8001ec2:	6803      	ldr	r3, [r0, #0]
 8001ec4:	4a3d      	ldr	r2, [pc, #244]	; (8001fbc <HAL_UART_Init+0x104>)
 8001ec6:	b1c9      	cbz	r1, 8001efc <HAL_UART_Init+0x44>
  { 
    /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
 8001ec8:	4293      	cmp	r3, r2
 8001eca:	d010      	beq.n	8001eee <HAL_UART_Init+0x36>
 8001ecc:	f5a2 424c 	sub.w	r2, r2, #52224	; 0xcc00
 8001ed0:	4293      	cmp	r3, r2
 8001ed2:	d00c      	beq.n	8001eee <HAL_UART_Init+0x36>
 8001ed4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001ed8:	4293      	cmp	r3, r2
 8001eda:	d008      	beq.n	8001eee <HAL_UART_Init+0x36>
 8001edc:	f502 424c 	add.w	r2, r2, #52224	; 0xcc00
 8001ee0:	4293      	cmp	r3, r2
 8001ee2:	d004      	beq.n	8001eee <HAL_UART_Init+0x36>
 8001ee4:	f44f 7181 	mov.w	r1, #258	; 0x102
 8001ee8:	4835      	ldr	r0, [pc, #212]	; (8001fc0 <HAL_UART_Init+0x108>)
 8001eea:	f000 fb02 	bl	80024f2 <assert_failed>
    assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
 8001eee:	69a3      	ldr	r3, [r4, #24]
 8001ef0:	f433 7340 	bics.w	r3, r3, #768	; 0x300
 8001ef4:	d024      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001ef6:	f240 1103 	movw	r1, #259	; 0x103
 8001efa:	e01e      	b.n	8001f3a <HAL_UART_Init+0x82>
  }
  else
  {
    assert_param(IS_UART_INSTANCE(huart->Instance));
 8001efc:	4293      	cmp	r3, r2
 8001efe:	d01f      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f00:	4a30      	ldr	r2, [pc, #192]	; (8001fc4 <HAL_UART_Init+0x10c>)
 8001f02:	4293      	cmp	r3, r2
 8001f04:	d01c      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f06:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f0a:	4293      	cmp	r3, r2
 8001f0c:	d018      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f0e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f12:	4293      	cmp	r3, r2
 8001f14:	d014      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f16:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f1a:	4293      	cmp	r3, r2
 8001f1c:	d010      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f1e:	f502 4244 	add.w	r2, r2, #50176	; 0xc400
 8001f22:	4293      	cmp	r3, r2
 8001f24:	d00c      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f26:	f5a2 421c 	sub.w	r2, r2, #39936	; 0x9c00
 8001f2a:	4293      	cmp	r3, r2
 8001f2c:	d008      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f2e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f32:	4293      	cmp	r3, r2
 8001f34:	d004      	beq.n	8001f40 <HAL_UART_Init+0x88>
 8001f36:	f240 1107 	movw	r1, #263	; 0x107
 8001f3a:	4821      	ldr	r0, [pc, #132]	; (8001fc0 <HAL_UART_Init+0x108>)
 8001f3c:	f000 fad9 	bl	80024f2 <assert_failed>
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
 8001f40:	68a3      	ldr	r3, [r4, #8]
 8001f42:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 8001f46:	d004      	beq.n	8001f52 <HAL_UART_Init+0x9a>
 8001f48:	f240 1109 	movw	r1, #265	; 0x109
 8001f4c:	481c      	ldr	r0, [pc, #112]	; (8001fc0 <HAL_UART_Init+0x108>)
 8001f4e:	f000 fad0 	bl	80024f2 <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
 8001f52:	69e3      	ldr	r3, [r4, #28]
 8001f54:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 8001f58:	d004      	beq.n	8001f64 <HAL_UART_Init+0xac>
 8001f5a:	f44f 7185 	mov.w	r1, #266	; 0x10a
 8001f5e:	4818      	ldr	r0, [pc, #96]	; (8001fc0 <HAL_UART_Init+0x108>)
 8001f60:	f000 fac7 	bl	80024f2 <assert_failed>
  
  if(huart->gState == HAL_UART_STATE_RESET)
 8001f64:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8001f68:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001f6c:	b923      	cbnz	r3, 8001f78 <HAL_UART_Init+0xc0>
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8001f6e:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8001f72:	4620      	mov	r0, r4
 8001f74:	f000 fb84 	bl	8002680 <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001f78:	6822      	ldr	r2, [r4, #0]
    huart->Lock = HAL_UNLOCKED;
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8001f7a:	2324      	movs	r3, #36	; 0x24
 8001f7c:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001f80:	68d3      	ldr	r3, [r2, #12]
 8001f82:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001f86:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8001f88:	4620      	mov	r0, r4
 8001f8a:	f7ff fe49 	bl	8001c20 <UART_SetConfig>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001f8e:	6823      	ldr	r3, [r4, #0]
 8001f90:	691a      	ldr	r2, [r3, #16]
 8001f92:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8001f96:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001f98:	695a      	ldr	r2, [r3, #20]
 8001f9a:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8001f9e:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8001fa0:	68da      	ldr	r2, [r3, #12]
 8001fa2:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001fa6:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001fa8:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 8001faa:	2320      	movs	r3, #32
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001fac:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8001fae:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8001fb2:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  
  return HAL_OK;
 8001fb6:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8001fb8:	2001      	movs	r0, #1
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState= HAL_UART_STATE_READY;
  huart->RxState= HAL_UART_STATE_READY;
  
  return HAL_OK;
}
 8001fba:	bd10      	pop	{r4, pc}
 8001fbc:	40011000 	.word	0x40011000
 8001fc0:	080027f4 	.word	0x080027f4
 8001fc4:	40004400 	.word	0x40004400

08001fc8 <SDIO_Init>:
  * @param  SDIOx: Pointer to SDIO register base
  * @param  Init: SDIO initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
{
 8001fc8:	b084      	sub	sp, #16
 8001fca:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001fce:	4606      	mov	r6, r0
 8001fd0:	a809      	add	r0, sp, #36	; 0x24
 8001fd2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0U; 

  /* Check the parameters */
  assert_param(IS_SDIO_ALL_INSTANCE(SDIOx));
 8001fd6:	4b27      	ldr	r3, [pc, #156]	; (8002074 <SDIO_Init+0xac>)
 8001fd8:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 8001fdc:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8001fe0:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8001fe2:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8001fe4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8001fe6:	429e      	cmp	r6, r3
 8001fe8:	468a      	mov	sl, r1
 8001fea:	d003      	beq.n	8001ff4 <SDIO_Init+0x2c>
 8001fec:	21de      	movs	r1, #222	; 0xde
 8001fee:	4822      	ldr	r0, [pc, #136]	; (8002078 <SDIO_Init+0xb0>)
 8001ff0:	f000 fa7f 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_CLOCK_EDGE(Init.ClockEdge)); 
 8001ff4:	f43a 5300 	bics.w	r3, sl, #8192	; 0x2000
 8001ff8:	d003      	beq.n	8002002 <SDIO_Init+0x3a>
 8001ffa:	21df      	movs	r1, #223	; 0xdf
 8001ffc:	481e      	ldr	r0, [pc, #120]	; (8002078 <SDIO_Init+0xb0>)
 8001ffe:	f000 fa78 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_CLOCK_BYPASS(Init.ClockBypass));
 8002002:	f439 6380 	bics.w	r3, r9, #1024	; 0x400
 8002006:	d003      	beq.n	8002010 <SDIO_Init+0x48>
 8002008:	21e0      	movs	r1, #224	; 0xe0
 800200a:	481b      	ldr	r0, [pc, #108]	; (8002078 <SDIO_Init+0xb0>)
 800200c:	f000 fa71 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_CLOCK_POWER_SAVE(Init.ClockPowerSave));
 8002010:	f438 7300 	bics.w	r3, r8, #512	; 0x200
 8002014:	d003      	beq.n	800201e <SDIO_Init+0x56>
 8002016:	21e1      	movs	r1, #225	; 0xe1
 8002018:	4817      	ldr	r0, [pc, #92]	; (8002078 <SDIO_Init+0xb0>)
 800201a:	f000 fa6a 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
 800201e:	f434 6300 	bics.w	r3, r4, #2048	; 0x800
 8002022:	d006      	beq.n	8002032 <SDIO_Init+0x6a>
 8002024:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8002028:	d003      	beq.n	8002032 <SDIO_Init+0x6a>
 800202a:	21e2      	movs	r1, #226	; 0xe2
 800202c:	4812      	ldr	r0, [pc, #72]	; (8002078 <SDIO_Init+0xb0>)
 800202e:	f000 fa60 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
 8002032:	f437 4380 	bics.w	r3, r7, #16384	; 0x4000
 8002036:	d003      	beq.n	8002040 <SDIO_Init+0x78>
 8002038:	21e3      	movs	r1, #227	; 0xe3
 800203a:	480f      	ldr	r0, [pc, #60]	; (8002078 <SDIO_Init+0xb0>)
 800203c:	f000 fa59 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
 8002040:	2dff      	cmp	r5, #255	; 0xff
 8002042:	d903      	bls.n	800204c <SDIO_Init+0x84>
 8002044:	21e4      	movs	r1, #228	; 0xe4
 8002046:	480c      	ldr	r0, [pc, #48]	; (8002078 <SDIO_Init+0xb0>)
 8002048:	f000 fa53 	bl	80024f2 <assert_failed>
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 800204c:	ea4a 0909 	orr.w	r9, sl, r9
 8002050:	6872      	ldr	r2, [r6, #4]
 8002052:	ea49 0808 	orr.w	r8, r9, r8
 8002056:	ea48 0404 	orr.w	r4, r8, r4
 800205a:	433c      	orrs	r4, r7
 800205c:	f422 43fd 	bic.w	r3, r2, #32384	; 0x7e80
 8002060:	4325      	orrs	r5, r4
 8002062:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8002066:	432b      	orrs	r3, r5
 8002068:	6073      	str	r3, [r6, #4]

  return HAL_OK;
}
 800206a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800206e:	2000      	movs	r0, #0
 8002070:	b004      	add	sp, #16
 8002072:	4770      	bx	lr
 8002074:	40012c00 	.word	0x40012c00
 8002078:	0800282d 	.word	0x0800282d

0800207c <SDIO_ReadFIFO>:
 800207c:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8002080:	4770      	bx	lr

08002082 <SDIO_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
{ 
  /* Write data to FIFO */ 
  SDIOx->FIFO = *pWriteData;
 8002082:	680b      	ldr	r3, [r1, #0]
 8002084:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
 8002088:	2000      	movs	r0, #0
 800208a:	4770      	bx	lr

0800208c <SDIO_PowerState_ON>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
{  
  /* Set power state to ON */ 
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 800208c:	2303      	movs	r3, #3
 800208e:	6003      	str	r3, [r0, #0]
  
  return HAL_OK; 
}
 8002090:	2000      	movs	r0, #0
 8002092:	4770      	bx	lr

08002094 <SDIO_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
{
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 8002094:	6800      	ldr	r0, [r0, #0]
}
 8002096:	f000 0003 	and.w	r0, r0, #3
 800209a:	4770      	bx	lr

0800209c <SDIO_SendCommand>:
  * @param  SDIO_CmdInitStruct: pointer to a SDIO_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDIO command
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 800209c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmpreg = 0U;
  
  /* Check the parameters */
  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->CmdIndex));
 800209e:	684b      	ldr	r3, [r1, #4]
 80020a0:	2b3f      	cmp	r3, #63	; 0x3f
  * @param  SDIO_CmdInitStruct: pointer to a SDIO_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDIO command
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 80020a2:	4605      	mov	r5, r0
 80020a4:	460c      	mov	r4, r1
  uint32_t tmpreg = 0U;
  
  /* Check the parameters */
  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->CmdIndex));
 80020a6:	d904      	bls.n	80020b2 <SDIO_SendCommand+0x16>
 80020a8:	f240 1169 	movw	r1, #361	; 0x169
 80020ac:	481a      	ldr	r0, [pc, #104]	; (8002118 <SDIO_SendCommand+0x7c>)
 80020ae:	f000 fa20 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
 80020b2:	68a3      	ldr	r3, [r4, #8]
 80020b4:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 80020b8:	d006      	beq.n	80020c8 <SDIO_SendCommand+0x2c>
 80020ba:	2bc0      	cmp	r3, #192	; 0xc0
 80020bc:	d004      	beq.n	80020c8 <SDIO_SendCommand+0x2c>
 80020be:	f44f 71b5 	mov.w	r1, #362	; 0x16a
 80020c2:	4815      	ldr	r0, [pc, #84]	; (8002118 <SDIO_SendCommand+0x7c>)
 80020c4:	f000 fa15 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
 80020c8:	68e3      	ldr	r3, [r4, #12]
 80020ca:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 80020ce:	d007      	beq.n	80020e0 <SDIO_SendCommand+0x44>
 80020d0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80020d4:	d004      	beq.n	80020e0 <SDIO_SendCommand+0x44>
 80020d6:	f240 116b 	movw	r1, #363	; 0x16b
 80020da:	480f      	ldr	r0, [pc, #60]	; (8002118 <SDIO_SendCommand+0x7c>)
 80020dc:	f000 fa09 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));
 80020e0:	6923      	ldr	r3, [r4, #16]
 80020e2:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
 80020e6:	d004      	beq.n	80020f2 <SDIO_SendCommand+0x56>
 80020e8:	f44f 71b6 	mov.w	r1, #364	; 0x16c
 80020ec:	480a      	ldr	r0, [pc, #40]	; (8002118 <SDIO_SendCommand+0x7c>)
 80020ee:	f000 fa00 	bl	80024f2 <assert_failed>

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 80020f2:	6823      	ldr	r3, [r4, #0]
 80020f4:	60ab      	str	r3, [r5, #8]
                       SDIO_CmdInitStruct->Response         |\
                       SDIO_CmdInitStruct->WaitForInterrupt |\
                       SDIO_CmdInitStruct->CPSM);
  
  /* Write to SDIO CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80020f6:	6861      	ldr	r1, [r4, #4]
 80020f8:	68a3      	ldr	r3, [r4, #8]
 80020fa:	68ea      	ldr	r2, [r5, #12]
 80020fc:	4319      	orrs	r1, r3
 80020fe:	68e3      	ldr	r3, [r4, #12]
 8002100:	430b      	orrs	r3, r1
 8002102:	6921      	ldr	r1, [r4, #16]
 8002104:	4319      	orrs	r1, r3
 8002106:	f422 637f 	bic.w	r3, r2, #4080	; 0xff0
 800210a:	f023 030f 	bic.w	r3, r3, #15
 800210e:	430b      	orrs	r3, r1
 8002110:	60eb      	str	r3, [r5, #12]
  
  return HAL_OK;  
}
 8002112:	2000      	movs	r0, #0
 8002114:	bd38      	pop	{r3, r4, r5, pc}
 8002116:	bf00      	nop
 8002118:	0800282d 	.word	0x0800282d

0800211c <SDIO_GetCommandResponse>:
  * @param  SDIOx: Pointer to SDIO register base
  * @retval Command index of the last command response received
  */
uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
{
  return (uint8_t)(SDIOx->RESPCMD);
 800211c:	6900      	ldr	r0, [r0, #16]
}
 800211e:	b2c0      	uxtb	r0, r0
 8002120:	4770      	bx	lr
	...

08002124 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 8002124:	b513      	push	{r0, r1, r4, lr}
  __IO uint32_t tmp = 0U;
 8002126:	2300      	movs	r3, #0
 8002128:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));
 800212a:	f030 030c 	bics.w	r3, r0, #12
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 800212e:	4604      	mov	r4, r0
  __IO uint32_t tmp = 0U;

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));
 8002130:	d004      	beq.n	800213c <SDIO_GetResponse+0x18>
 8002132:	f240 1197 	movw	r1, #407	; 0x197
 8002136:	4805      	ldr	r0, [pc, #20]	; (800214c <SDIO_GetResponse+0x28>)
 8002138:	f000 f9db 	bl	80024f2 <assert_failed>

  /* Get the response */
  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 800213c:	4b04      	ldr	r3, [pc, #16]	; (8002150 <SDIO_GetResponse+0x2c>)
 800213e:	4423      	add	r3, r4
 8002140:	9301      	str	r3, [sp, #4]
  
  return (*(__IO uint32_t *) tmp);
 8002142:	9b01      	ldr	r3, [sp, #4]
 8002144:	6818      	ldr	r0, [r3, #0]
}  
 8002146:	b002      	add	sp, #8
 8002148:	bd10      	pop	{r4, pc}
 800214a:	bf00      	nop
 800214c:	0800282d 	.word	0x0800282d
 8002150:	40012c14 	.word	0x40012c14

08002154 <SDIO_DataConfig>:
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_DataConfig(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 8002154:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmpreg = 0U;
  
  /* Check the parameters */
  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->DataLength));
 8002156:	684b      	ldr	r3, [r1, #4]
 8002158:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_DataConfig(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 800215c:	4605      	mov	r5, r0
 800215e:	460c      	mov	r4, r1
  uint32_t tmpreg = 0U;
  
  /* Check the parameters */
  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->DataLength));
 8002160:	d304      	bcc.n	800216c <SDIO_DataConfig+0x18>
 8002162:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
 8002166:	4821      	ldr	r0, [pc, #132]	; (80021ec <SDIO_DataConfig+0x98>)
 8002168:	f000 f9c3 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->DataBlockSize));
 800216c:	68a3      	ldr	r3, [r4, #8]
 800216e:	f033 0230 	bics.w	r2, r3, #48	; 0x30
 8002172:	f023 0110 	bic.w	r1, r3, #16
 8002176:	d00c      	beq.n	8002192 <SDIO_DataConfig+0x3e>
 8002178:	2a40      	cmp	r2, #64	; 0x40
 800217a:	d00a      	beq.n	8002192 <SDIO_DataConfig+0x3e>
 800217c:	2a80      	cmp	r2, #128	; 0x80
 800217e:	d008      	beq.n	8002192 <SDIO_DataConfig+0x3e>
 8002180:	29c0      	cmp	r1, #192	; 0xc0
 8002182:	d006      	beq.n	8002192 <SDIO_DataConfig+0x3e>
 8002184:	2be0      	cmp	r3, #224	; 0xe0
 8002186:	d004      	beq.n	8002192 <SDIO_DataConfig+0x3e>
 8002188:	f240 11ad 	movw	r1, #429	; 0x1ad
 800218c:	4817      	ldr	r0, [pc, #92]	; (80021ec <SDIO_DataConfig+0x98>)
 800218e:	f000 f9b0 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
 8002192:	68e3      	ldr	r3, [r4, #12]
 8002194:	f033 0302 	bics.w	r3, r3, #2
 8002198:	d004      	beq.n	80021a4 <SDIO_DataConfig+0x50>
 800219a:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 800219e:	4813      	ldr	r0, [pc, #76]	; (80021ec <SDIO_DataConfig+0x98>)
 80021a0:	f000 f9a7 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
 80021a4:	6923      	ldr	r3, [r4, #16]
 80021a6:	f033 0304 	bics.w	r3, r3, #4
 80021aa:	d004      	beq.n	80021b6 <SDIO_DataConfig+0x62>
 80021ac:	f240 11af 	movw	r1, #431	; 0x1af
 80021b0:	480e      	ldr	r0, [pc, #56]	; (80021ec <SDIO_DataConfig+0x98>)
 80021b2:	f000 f99e 	bl	80024f2 <assert_failed>
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));
 80021b6:	6963      	ldr	r3, [r4, #20]
 80021b8:	2b01      	cmp	r3, #1
 80021ba:	d904      	bls.n	80021c6 <SDIO_DataConfig+0x72>
 80021bc:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 80021c0:	480a      	ldr	r0, [pc, #40]	; (80021ec <SDIO_DataConfig+0x98>)
 80021c2:	f000 f996 	bl	80024f2 <assert_failed>
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80021c6:	68e2      	ldr	r2, [r4, #12]
 80021c8:	68a1      	ldr	r1, [r4, #8]
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;
 80021ca:	6823      	ldr	r3, [r4, #0]
 80021cc:	626b      	str	r3, [r5, #36]	; 0x24
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80021ce:	4311      	orrs	r1, r2

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 80021d0:	6863      	ldr	r3, [r4, #4]
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80021d2:	6922      	ldr	r2, [r4, #16]

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 80021d4:	62ab      	str	r3, [r5, #40]	; 0x28
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80021d6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80021d8:	4311      	orrs	r1, r2
 80021da:	6962      	ldr	r2, [r4, #20]
 80021dc:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
 80021e0:	430a      	orrs	r2, r1
 80021e2:	4313      	orrs	r3, r2
 80021e4:	62eb      	str	r3, [r5, #44]	; 0x2c

  return HAL_OK;

}
 80021e6:	2000      	movs	r0, #0
 80021e8:	bd38      	pop	{r3, r4, r5, pc}
 80021ea:	bf00      	nop
 80021ec:	0800282d 	.word	0x0800282d

080021f0 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used 
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 80021f0:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 80021f2:	4c06      	ldr	r4, [pc, #24]	; (800220c <SD_initialize+0x1c>)
 80021f4:	2301      	movs	r3, #1
 80021f6:	7023      	strb	r3, [r4, #0]
  
  /* Configure the uSD device */
  if(BSP_SD_Init() == MSD_OK)
 80021f8:	f000 f88a 	bl	8002310 <BSP_SD_Init>
 80021fc:	4623      	mov	r3, r4
 80021fe:	b918      	cbnz	r0, 8002208 <SD_initialize+0x18>
  {
    Stat &= ~STA_NOINIT;
 8002200:	7822      	ldrb	r2, [r4, #0]
 8002202:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8002206:	7022      	strb	r2, [r4, #0]
  }

  return Stat;
 8002208:	7818      	ldrb	r0, [r3, #0]
}
 800220a:	bd10      	pop	{r4, pc}
 800220c:	20000000 	.word	0x20000000

08002210 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 8002210:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 8002212:	4c06      	ldr	r4, [pc, #24]	; (800222c <SD_status+0x1c>)
 8002214:	2301      	movs	r3, #1
 8002216:	7023      	strb	r3, [r4, #0]

  if(BSP_SD_GetStatus() == MSD_OK)
 8002218:	f000 f8ba 	bl	8002390 <BSP_SD_GetStatus>
 800221c:	4623      	mov	r3, r4
 800221e:	b918      	cbnz	r0, 8002228 <SD_status+0x18>
  {
    Stat &= ~STA_NOINIT;
 8002220:	7822      	ldrb	r2, [r4, #0]
 8002222:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8002226:	7022      	strb	r2, [r4, #0]
  }
  
  return Stat;
 8002228:	7818      	ldrb	r0, [r3, #0]
}
 800222a:	bd10      	pop	{r4, pc}
 800222c:	20000000 	.word	0x20000000

08002230 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8002230:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 8002232:	9301      	str	r3, [sp, #4]
 8002234:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002238:	9300      	str	r3, [sp, #0]
 800223a:	0252      	lsls	r2, r2, #9
 800223c:	2300      	movs	r3, #0
 800223e:	4608      	mov	r0, r1
 8002240:	f000 f882 	bl	8002348 <BSP_SD_ReadBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 8002244:	3000      	adds	r0, #0
 8002246:	bf18      	it	ne
 8002248:	2001      	movne	r0, #1
 800224a:	b003      	add	sp, #12
 800224c:	f85d fb04 	ldr.w	pc, [sp], #4

08002250 <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 8002250:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 8002252:	9301      	str	r3, [sp, #4]
 8002254:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002258:	9300      	str	r3, [sp, #0]
 800225a:	0252      	lsls	r2, r2, #9
 800225c:	2300      	movs	r3, #0
 800225e:	4608      	mov	r0, r1
 8002260:	f000 f884 	bl	800236c <BSP_SD_WriteBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 8002264:	3000      	adds	r0, #0
 8002266:	bf18      	it	ne
 8002268:	2001      	movne	r0, #1
 800226a:	b003      	add	sp, #12
 800226c:	f85d fb04 	ldr.w	pc, [sp], #4

08002270 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8002270:	b510      	push	{r4, lr}
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8002272:	4b13      	ldr	r3, [pc, #76]	; (80022c0 <SD_ioctl+0x50>)
 8002274:	781b      	ldrb	r3, [r3, #0]
 8002276:	07db      	lsls	r3, r3, #31
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8002278:	b096      	sub	sp, #88	; 0x58
 800227a:	4614      	mov	r4, r2
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800227c:	d41a      	bmi.n	80022b4 <SD_ioctl+0x44>
  
  switch (cmd)
 800227e:	2903      	cmp	r1, #3
 8002280:	d803      	bhi.n	800228a <SD_ioctl+0x1a>
 8002282:	e8df f001 	tbb	[pc, r1]
 8002286:	0419      	.short	0x0419
 8002288:	120e      	.short	0x120e
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
  
  default:
    res = RES_PARERR;
 800228a:	2004      	movs	r0, #4
 800228c:	e015      	b.n	80022ba <SD_ioctl+0x4a>
    res = RES_OK;
    break;
  
  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    BSP_SD_GetCardInfo(&CardInfo);
 800228e:	4668      	mov	r0, sp
 8002290:	f000 f884 	bl	800239c <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.CardCapacity / BLOCK_SIZE;
 8002294:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8002296:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8002298:	0a5b      	lsrs	r3, r3, #9
 800229a:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 800229e:	6023      	str	r3, [r4, #0]
 80022a0:	e00a      	b.n	80022b8 <SD_ioctl+0x48>
    res = RES_OK;
    break;
  
  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    *(WORD*)buff = BLOCK_SIZE;
 80022a2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80022a6:	8013      	strh	r3, [r2, #0]
 80022a8:	e006      	b.n	80022b8 <SD_ioctl+0x48>
    res = RES_OK;
    break;
  
  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
 80022aa:	f44f 7300 	mov.w	r3, #512	; 0x200
 80022ae:	6013      	str	r3, [r2, #0]
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
 80022b0:	2001      	movs	r0, #1
    break;
  
  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
 80022b2:	e002      	b.n	80022ba <SD_ioctl+0x4a>
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80022b4:	2003      	movs	r0, #3
 80022b6:	e000      	b.n	80022ba <SD_ioctl+0x4a>
  
  switch (cmd)
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC :
    res = RES_OK;
 80022b8:	2000      	movs	r0, #0
  default:
    res = RES_PARERR;
  }
  
  return res;
}
 80022ba:	b016      	add	sp, #88	; 0x58
 80022bc:	bd10      	pop	{r4, pc}
 80022be:	bf00      	nop
 80022c0:	20000000 	.word	0x20000000

080022c4 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 80022c4:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
  uint8_t DiskNum = 0;
  
  if(disk.nbr <= _VOLUMES)
 80022c6:	4b0f      	ldr	r3, [pc, #60]	; (8002304 <FATFS_LinkDriverEx+0x40>)
 80022c8:	7a5c      	ldrb	r4, [r3, #9]
 80022ca:	2c01      	cmp	r4, #1
 80022cc:	d818      	bhi.n	8002300 <FATFS_LinkDriverEx+0x3c>
  {
    disk.is_initialized[disk.nbr] = 0;
 80022ce:	7a5d      	ldrb	r5, [r3, #9]
 80022d0:	b2ed      	uxtb	r5, r5
 80022d2:	2400      	movs	r4, #0
 80022d4:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;  
 80022d6:	7a5d      	ldrb	r5, [r3, #9]
 80022d8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80022dc:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;  
 80022de:	7a58      	ldrb	r0, [r3, #9]
 80022e0:	4418      	add	r0, r3
 80022e2:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 80022e4:	7a5a      	ldrb	r2, [r3, #9]
 80022e6:	b2d2      	uxtb	r2, r2
 80022e8:	1c50      	adds	r0, r2, #1
 80022ea:	b2c0      	uxtb	r0, r0
 80022ec:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 80022ee:	233a      	movs	r3, #58	; 0x3a
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 80022f0:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 80022f2:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 80022f4:	232f      	movs	r3, #47	; 0x2f
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 80022f6:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
    path[2] = '/';
 80022f8:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 80022fa:	70cc      	strb	r4, [r1, #3]
 80022fc:	4620      	mov	r0, r4
 80022fe:	bd30      	pop	{r4, r5, pc}
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
 8002300:	2001      	movs	r0, #1
    path[3] = 0;
    ret = 0;
  }
  
  return ret;
}
 8002302:	bd30      	pop	{r4, r5, pc}
 8002304:	20000024 	.word	0x20000024

08002308 <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path 
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
 8002308:	2200      	movs	r2, #0
 800230a:	f7ff bfdb 	b.w	80022c4 <FATFS_LinkDriverEx>
	...

08002310 <BSP_SD_Init>:
/**
  * @brief  Initializes the SD card device.
  * @retval SD status
  */
uint8_t BSP_SD_Init(void)
{
 8002310:	b507      	push	{r0, r1, r2, lr}
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @retval Returns if SD is detected or not
 */
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t status = SD_PRESENT;
 8002312:	2001      	movs	r0, #1
 8002314:	f88d 0007 	strb.w	r0, [sp, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */    	

  return status;
 8002318:	f89d 3007 	ldrb.w	r3, [sp, #7]
  */
uint8_t BSP_SD_Init(void)
{
  uint8_t sd_state = MSD_OK;
  /* Check if the SD card is plugged in the slot */
  if (BSP_SD_IsDetected() != SD_PRESENT)
 800231c:	4283      	cmp	r3, r0
 800231e:	d10c      	bne.n	800233a <BSP_SD_Init+0x2a>
  {
    return MSD_ERROR;
  }
  /* HAL SD initialization */
  sd_state = HAL_SD_Init(&hsd, &SDCardInfo);
 8002320:	4907      	ldr	r1, [pc, #28]	; (8002340 <BSP_SD_Init+0x30>)
 8002322:	4808      	ldr	r0, [pc, #32]	; (8002344 <BSP_SD_Init+0x34>)
 8002324:	f7ff f82e 	bl	8001384 <HAL_SD_Init>
#ifdef BUS_4BITS
  /* Configure SD Bus width */
  if (sd_state == MSD_OK)
 8002328:	b938      	cbnz	r0, 800233a <BSP_SD_Init+0x2a>
  {
    /* Enable wide operation */
    if (HAL_SD_WideBusOperation_Config(&hsd, SDIO_BUS_WIDE_4B) != SD_OK)
 800232a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800232e:	4805      	ldr	r0, [pc, #20]	; (8002344 <BSP_SD_Init+0x34>)
 8002330:	f7ff f9ee 	bl	8001710 <HAL_SD_WideBusOperation_Config>
{
  uint8_t sd_state = MSD_OK;
  /* Check if the SD card is plugged in the slot */
  if (BSP_SD_IsDetected() != SD_PRESENT)
  {
    return MSD_ERROR;
 8002334:	3000      	adds	r0, #0
 8002336:	bf18      	it	ne
 8002338:	2001      	movne	r0, #1
      sd_state = MSD_OK;
    }
  }
#endif
  return sd_state;
}
 800233a:	b003      	add	sp, #12
 800233c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002340:	20000040 	.word	0x20000040
 8002344:	20000098 	.word	0x20000098

08002348 <BSP_SD_ReadBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to read 
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 8002348:	b507      	push	{r0, r1, r2, lr}
  uint8_t sd_state;
  if(HAL_SD_ReadBlocks(&hsd, pData, ReadAddr, BlockSize, NumOfBlocks) != SD_OK)
 800234a:	9905      	ldr	r1, [sp, #20]
 800234c:	9101      	str	r1, [sp, #4]
 800234e:	9904      	ldr	r1, [sp, #16]
 8002350:	9100      	str	r1, [sp, #0]
 8002352:	4601      	mov	r1, r0
 8002354:	4804      	ldr	r0, [pc, #16]	; (8002368 <BSP_SD_ReadBlocks+0x20>)
 8002356:	f7ff fa88 	bl	800186a <HAL_SD_ReadBlocks>
  else
  {
    sd_state = MSD_OK;
  }
  return sd_state;  
}
 800235a:	3000      	adds	r0, #0
 800235c:	bf18      	it	ne
 800235e:	2001      	movne	r0, #1
 8002360:	b003      	add	sp, #12
 8002362:	f85d fb04 	ldr.w	pc, [sp], #4
 8002366:	bf00      	nop
 8002368:	20000098 	.word	0x20000098

0800236c <BSP_SD_WriteBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 800236c:	b507      	push	{r0, r1, r2, lr}
  uint8_t sd_state;
  if(HAL_SD_WriteBlocks(&hsd, pData, WriteAddr, BlockSize, NumOfBlocks) != SD_OK)  
 800236e:	9905      	ldr	r1, [sp, #20]
 8002370:	9101      	str	r1, [sp, #4]
 8002372:	9904      	ldr	r1, [sp, #16]
 8002374:	9100      	str	r1, [sp, #0]
 8002376:	4601      	mov	r1, r0
 8002378:	4804      	ldr	r0, [pc, #16]	; (800238c <BSP_SD_WriteBlocks+0x20>)
 800237a:	f7ff fb38 	bl	80019ee <HAL_SD_WriteBlocks>
  else
  {
    sd_state = MSD_OK;
  }
  return sd_state;  
}
 800237e:	3000      	adds	r0, #0
 8002380:	bf18      	it	ne
 8002382:	2001      	movne	r0, #1
 8002384:	b003      	add	sp, #12
 8002386:	f85d fb04 	ldr.w	pc, [sp], #4
 800238a:	bf00      	nop
 800238c:	20000098 	.word	0x20000098

08002390 <BSP_SD_GetStatus>:
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  *            @arg  SD_TRANSFER_ERROR: Data transfer error 
  */
HAL_SD_TransferStateTypedef BSP_SD_GetStatus(void)
{
  return(HAL_SD_GetStatus(&hsd));
 8002390:	4801      	ldr	r0, [pc, #4]	; (8002398 <BSP_SD_GetStatus+0x8>)
 8002392:	f7ff bc22 	b.w	8001bda <HAL_SD_GetStatus>
 8002396:	bf00      	nop
 8002398:	20000098 	.word	0x20000098

0800239c <BSP_SD_GetCardInfo>:
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  */
void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypedef* CardInfo)
{
  /* Get SD card Information */
  HAL_SD_Get_CardInfo(&hsd, CardInfo);
 800239c:	4601      	mov	r1, r0
 800239e:	4801      	ldr	r0, [pc, #4]	; (80023a4 <BSP_SD_GetCardInfo+0x8>)
 80023a0:	f7fe bead 	b.w	80010fe <HAL_SD_Get_CardInfo>
 80023a4:	20000098 	.word	0x20000098

080023a8 <MX_FATFS_Init>:

uint8_t retSD;    /* Return value for SD */
char SD_Path[4];  /* SD logical drive path */

void MX_FATFS_Init(void) 
{
 80023a8:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SD_Path);
 80023aa:	4903      	ldr	r1, [pc, #12]	; (80023b8 <MX_FATFS_Init+0x10>)
 80023ac:	4803      	ldr	r0, [pc, #12]	; (80023bc <MX_FATFS_Init+0x14>)
 80023ae:	f7ff ffab 	bl	8002308 <FATFS_LinkDriver>
 80023b2:	4b03      	ldr	r3, [pc, #12]	; (80023c0 <MX_FATFS_Init+0x18>)
 80023b4:	7018      	strb	r0, [r3, #0]
 80023b6:	bd08      	pop	{r3, pc}
 80023b8:	20000035 	.word	0x20000035
 80023bc:	08002868 	.word	0x08002868
 80023c0:	20000034 	.word	0x20000034

080023c4 <MX_GPIO_Init>:
#include "gpio.h"

void MX_GPIO_Init(void)
{
 80023c4:	b084      	sub	sp, #16

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80023c6:	4b16      	ldr	r3, [pc, #88]	; (8002420 <MX_GPIO_Init+0x5c>)
 80023c8:	2200      	movs	r2, #0
 80023ca:	9200      	str	r2, [sp, #0]
 80023cc:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80023ce:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80023d2:	6319      	str	r1, [r3, #48]	; 0x30
 80023d4:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80023d6:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80023da:	9100      	str	r1, [sp, #0]
 80023dc:	9900      	ldr	r1, [sp, #0]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80023de:	9201      	str	r2, [sp, #4]
 80023e0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80023e2:	f041 0104 	orr.w	r1, r1, #4
 80023e6:	6319      	str	r1, [r3, #48]	; 0x30
 80023e8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80023ea:	f001 0104 	and.w	r1, r1, #4
 80023ee:	9101      	str	r1, [sp, #4]
 80023f0:	9901      	ldr	r1, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80023f2:	9202      	str	r2, [sp, #8]
 80023f4:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80023f6:	f041 0101 	orr.w	r1, r1, #1
 80023fa:	6319      	str	r1, [r3, #48]	; 0x30
 80023fc:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80023fe:	f001 0101 	and.w	r1, r1, #1
 8002402:	9102      	str	r1, [sp, #8]
 8002404:	9902      	ldr	r1, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8002406:	9203      	str	r2, [sp, #12]
 8002408:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800240a:	f042 0208 	orr.w	r2, r2, #8
 800240e:	631a      	str	r2, [r3, #48]	; 0x30
 8002410:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002412:	f003 0308 	and.w	r3, r3, #8
 8002416:	9303      	str	r3, [sp, #12]
 8002418:	9b03      	ldr	r3, [sp, #12]

}
 800241a:	b004      	add	sp, #16
 800241c:	4770      	bx	lr
 800241e:	bf00      	nop
 8002420:	40023800 	.word	0x40023800

08002424 <SystemClock_Config>:
  {
  }
}

void SystemClock_Config(void)
{
 8002424:	b510      	push	{r4, lr}
 8002426:	b094      	sub	sp, #80	; 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 8002428:	4b28      	ldr	r3, [pc, #160]	; (80024cc <SystemClock_Config+0xa8>)
 800242a:	2100      	movs	r1, #0
 800242c:	9101      	str	r1, [sp, #4]
 800242e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002430:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002434:	641a      	str	r2, [r3, #64]	; 0x40
 8002436:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002438:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800243c:	9301      	str	r3, [sp, #4]
 800243e:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002440:	4b23      	ldr	r3, [pc, #140]	; (80024d0 <SystemClock_Config+0xac>)
 8002442:	9102      	str	r1, [sp, #8]
 8002444:	681a      	ldr	r2, [r3, #0]
 8002446:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800244a:	601a      	str	r2, [r3, #0]
 800244c:	681b      	ldr	r3, [r3, #0]
 800244e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8002452:	9302      	str	r3, [sp, #8]
 8002454:	9b02      	ldr	r3, [sp, #8]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8002456:	2301      	movs	r3, #1
 8002458:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800245a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800245e:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8002460:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8002464:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 24;
 8002466:	2318      	movs	r3, #24
 8002468:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 336;
 800246a:	f44f 73a8 	mov.w	r3, #336	; 0x150

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800246e:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 24;
  RCC_OscInitStruct.PLL.PLLN = 336;
 8002470:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 8;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002472:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 24;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 8;
 8002474:	2308      	movs	r3, #8

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002476:	940e      	str	r4, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 24;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8002478:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 8;
 800247a:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800247c:	f7fe f912 	bl	80006a4 <HAL_RCC_OscConfig>
 8002480:	b100      	cbz	r0, 8002484 <SystemClock_Config+0x60>
 8002482:	e7fe      	b.n	8002482 <SystemClock_Config+0x5e>
    Error_Handler();
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002484:	230f      	movs	r3, #15
 8002486:	9303      	str	r3, [sp, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8002488:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800248c:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800248e:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8002490:	2105      	movs	r1, #5
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8002492:	f44f 5380 	mov.w	r3, #4096	; 0x1000

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8002496:	a803      	add	r0, sp, #12

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002498:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800249a:	9307      	str	r3, [sp, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 800249c:	f7fe fb42 	bl	8000b24 <HAL_RCC_ClockConfig>
 80024a0:	4604      	mov	r4, r0
 80024a2:	b100      	cbz	r0, 80024a6 <SystemClock_Config+0x82>
 80024a4:	e7fe      	b.n	80024a4 <SystemClock_Config+0x80>
    Error_Handler();
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80024a6:	f7fe fc47 	bl	8000d38 <HAL_RCC_GetHCLKFreq>
 80024aa:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80024ae:	fbb0 f0f3 	udiv	r0, r0, r3
 80024b2:	f7fd ff6f 	bl	8000394 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80024b6:	2004      	movs	r0, #4
 80024b8:	f7fd ff82 	bl	80003c0 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80024bc:	4622      	mov	r2, r4
 80024be:	4621      	mov	r1, r4
 80024c0:	f04f 30ff 	mov.w	r0, #4294967295
 80024c4:	f7fd ff22 	bl	800030c <HAL_NVIC_SetPriority>
}
 80024c8:	b014      	add	sp, #80	; 0x50
 80024ca:	bd10      	pop	{r4, pc}
 80024cc:	40023800 	.word	0x40023800
 80024d0:	40007000 	.word	0x40007000

080024d4 <main>:

void SystemClock_Config(void);
void Error_Handler(void);

int main(void)
{
 80024d4:	b508      	push	{r3, lr}
  HAL_Init();
 80024d6:	f7fd fec7 	bl	8000268 <HAL_Init>
  SystemClock_Config();
 80024da:	f7ff ffa3 	bl	8002424 <SystemClock_Config>
  MX_GPIO_Init();
 80024de:	f7ff ff71 	bl	80023c4 <MX_GPIO_Init>
  MX_USART1_UART_Init();
 80024e2:	f000 f8b1 	bl	8002648 <MX_USART1_UART_Init>
  MX_SDIO_SD_Init();
 80024e6:	f000 f805 	bl	80024f4 <MX_SDIO_SD_Init>
  MX_FATFS_Init();
 80024ea:	f7ff ff5d 	bl	80023a8 <MX_FATFS_Init>
 80024ee:	e7fe      	b.n	80024ee <main+0x1a>

080024f0 <Error_Handler>:
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
}

void Error_Handler(void)
{
 80024f0:	e7fe      	b.n	80024f0 <Error_Handler>

080024f2 <assert_failed>:
  }
}

#ifdef USE_FULL_ASSERT
void assert_failed(uint8_t* file, uint32_t line)
{
 80024f2:	4770      	bx	lr

080024f4 <MX_SDIO_SD_Init>:
/* SDIO init function */

void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
 80024f4:	4b05      	ldr	r3, [pc, #20]	; (800250c <MX_SDIO_SD_Init+0x18>)
 80024f6:	4a06      	ldr	r2, [pc, #24]	; (8002510 <MX_SDIO_SD_Init+0x1c>)
 80024f8:	601a      	str	r2, [r3, #0]
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
 80024fa:	2200      	movs	r2, #0
 80024fc:	605a      	str	r2, [r3, #4]
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
 80024fe:	609a      	str	r2, [r3, #8]
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8002500:	60da      	str	r2, [r3, #12]
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
 8002502:	611a      	str	r2, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8002504:	615a      	str	r2, [r3, #20]
  hsd.Init.ClockDiv = 0;
 8002506:	619a      	str	r2, [r3, #24]
 8002508:	4770      	bx	lr
 800250a:	bf00      	nop
 800250c:	20000098 	.word	0x20000098
 8002510:	40012c00 	.word	0x40012c00

08002514 <HAL_SD_MspInit>:

}

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
 8002514:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(sdHandle->Instance==SDIO)
 8002516:	6802      	ldr	r2, [r0, #0]
 8002518:	4b15      	ldr	r3, [pc, #84]	; (8002570 <HAL_SD_MspInit+0x5c>)
 800251a:	429a      	cmp	r2, r3
  hsd.Init.ClockDiv = 0;

}

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
 800251c:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct;
  if(sdHandle->Instance==SDIO)
 800251e:	d125      	bne.n	800256c <HAL_SD_MspInit+0x58>
  {
    /* Peripheral clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 8002520:	2400      	movs	r4, #0
 8002522:	f503 3386 	add.w	r3, r3, #68608	; 0x10c00
 8002526:	9400      	str	r4, [sp, #0]
 8002528:	6c5a      	ldr	r2, [r3, #68]	; 0x44
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800252a:	4812      	ldr	r0, [pc, #72]	; (8002574 <HAL_SD_MspInit+0x60>)

  GPIO_InitTypeDef GPIO_InitStruct;
  if(sdHandle->Instance==SDIO)
  {
    /* Peripheral clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 800252c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8002530:	645a      	str	r2, [r3, #68]	; 0x44
 8002532:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002534:	9403      	str	r4, [sp, #12]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(sdHandle->Instance==SDIO)
  {
    /* Peripheral clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 8002536:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800253a:	9300      	str	r3, [sp, #0]
 800253c:	9b00      	ldr	r3, [sp, #0]
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800253e:	2702      	movs	r7, #2
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 8002540:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002544:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 8002546:	250c      	movs	r5, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8002548:	a901      	add	r1, sp, #4
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 800254a:	9301      	str	r3, [sp, #4]
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800254c:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800254e:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 8002550:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8002552:	f7fd ff53 	bl	80003fc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8002556:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002558:	eb0d 0103 	add.w	r1, sp, r3
 800255c:	4806      	ldr	r0, [pc, #24]	; (8002578 <HAL_SD_MspInit+0x64>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800255e:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002560:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002562:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002564:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 8002566:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002568:	f7fd ff48 	bl	80003fc <HAL_GPIO_Init>
  }
}
 800256c:	b007      	add	sp, #28
 800256e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002570:	40012c00 	.word	0x40012c00
 8002574:	40020800 	.word	0x40020800
 8002578:	40020c00 	.word	0x40020c00

0800257c <HAL_MspInit>:
#include "stm32f4xx_hal.h"

extern void Error_Handler(void);
void HAL_MspInit(void)
{
 800257c:	b508      	push	{r3, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800257e:	2003      	movs	r0, #3
 8002580:	f7fd fea8 	bl	80002d4 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8002584:	2200      	movs	r2, #0
 8002586:	4611      	mov	r1, r2
 8002588:	f06f 000b 	mvn.w	r0, #11
 800258c:	f7fd febe 	bl	800030c <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8002590:	2200      	movs	r2, #0
 8002592:	4611      	mov	r1, r2
 8002594:	f06f 000a 	mvn.w	r0, #10
 8002598:	f7fd feb8 	bl	800030c <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 800259c:	2200      	movs	r2, #0
 800259e:	4611      	mov	r1, r2
 80025a0:	f06f 0009 	mvn.w	r0, #9
 80025a4:	f7fd feb2 	bl	800030c <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80025a8:	2200      	movs	r2, #0
 80025aa:	4611      	mov	r1, r2
 80025ac:	f06f 0004 	mvn.w	r0, #4
 80025b0:	f7fd feac 	bl	800030c <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80025b4:	2200      	movs	r2, #0
 80025b6:	4611      	mov	r1, r2
 80025b8:	f06f 0003 	mvn.w	r0, #3
 80025bc:	f7fd fea6 	bl	800030c <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 80025c0:	2200      	movs	r2, #0
 80025c2:	4611      	mov	r1, r2
 80025c4:	f06f 0001 	mvn.w	r0, #1
 80025c8:	f7fd fea0 	bl	800030c <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80025cc:	2200      	movs	r2, #0
 80025ce:	4611      	mov	r1, r2
 80025d0:	f04f 30ff 	mov.w	r0, #4294967295

}
 80025d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80025d8:	f7fd be98 	b.w	800030c <HAL_NVIC_SetPriority>

080025dc <NMI_Handler>:
 80025dc:	4770      	bx	lr

080025de <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 80025de:	e7fe      	b.n	80025de <HardFault_Handler>

080025e0 <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 80025e0:	e7fe      	b.n	80025e0 <MemManage_Handler>

080025e2 <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 80025e2:	e7fe      	b.n	80025e2 <BusFault_Handler>

080025e4 <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 80025e4:	e7fe      	b.n	80025e4 <UsageFault_Handler>

080025e6 <SVC_Handler>:
 80025e6:	4770      	bx	lr

080025e8 <DebugMon_Handler>:
 80025e8:	4770      	bx	lr

080025ea <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 80025ea:	4770      	bx	lr

080025ec <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80025ec:	b508      	push	{r3, lr}
  HAL_IncTick();
 80025ee:	f7fd fe55 	bl	800029c <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
}
 80025f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 80025f6:	f7fd befc 	b.w	80003f2 <HAL_SYSTICK_IRQHandler>
	...

080025fc <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80025fc:	490f      	ldr	r1, [pc, #60]	; (800263c <SystemInit+0x40>)
 80025fe:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8002602:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8002606:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800260a:	4b0d      	ldr	r3, [pc, #52]	; (8002640 <SystemInit+0x44>)
 800260c:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800260e:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8002610:	f042 0201 	orr.w	r2, r2, #1
 8002614:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002616:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8002618:	681a      	ldr	r2, [r3, #0]
 800261a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800261e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002622:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8002624:	4a07      	ldr	r2, [pc, #28]	; (8002644 <SystemInit+0x48>)
 8002626:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002628:	681a      	ldr	r2, [r3, #0]
 800262a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800262e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8002630:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002632:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8002636:	608b      	str	r3, [r1, #8]
 8002638:	4770      	bx	lr
 800263a:	bf00      	nop
 800263c:	e000ed00 	.word	0xe000ed00
 8002640:	40023800 	.word	0x40023800
 8002644:	24003010 	.word	0x24003010

08002648 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 8002648:	b508      	push	{r3, lr}

  huart1.Instance = USART1;
 800264a:	480b      	ldr	r0, [pc, #44]	; (8002678 <MX_USART1_UART_Init+0x30>)
  huart1.Init.BaudRate = 115200;
 800264c:	4b0b      	ldr	r3, [pc, #44]	; (800267c <MX_USART1_UART_Init+0x34>)
 800264e:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
 8002652:	e880 4008 	stmia.w	r0, {r3, lr}
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
 8002656:	220c      	movs	r2, #12
void MX_USART1_UART_Init(void)
{

  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8002658:	2300      	movs	r3, #0
 800265a:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 800265c:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800265e:	6103      	str	r3, [r0, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8002660:	6142      	str	r2, [r0, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8002662:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8002664:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8002666:	f7ff fc27 	bl	8001eb8 <HAL_UART_Init>
 800266a:	b118      	cbz	r0, 8002674 <MX_USART1_UART_Init+0x2c>
  {
    Error_Handler();
  }

}
 800266c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
 8002670:	f7ff bf3e 	b.w	80024f0 <Error_Handler>
 8002674:	bd08      	pop	{r3, pc}
 8002676:	bf00      	nop
 8002678:	200000f8 	.word	0x200000f8
 800267c:	40011000 	.word	0x40011000

08002680 <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8002680:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(uartHandle->Instance==USART1)
 8002682:	6802      	ldr	r2, [r0, #0]
 8002684:	4b10      	ldr	r3, [pc, #64]	; (80026c8 <HAL_UART_MspInit+0x48>)
 8002686:	429a      	cmp	r2, r3
 8002688:	d11a      	bne.n	80026c0 <HAL_UART_MspInit+0x40>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800268a:	2300      	movs	r3, #0
 800268c:	9300      	str	r3, [sp, #0]
 800268e:	4b0f      	ldr	r3, [pc, #60]	; (80026cc <HAL_UART_MspInit+0x4c>)
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002690:	480f      	ldr	r0, [pc, #60]	; (80026d0 <HAL_UART_MspInit+0x50>)
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8002692:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002694:	f042 0210 	orr.w	r2, r2, #16
 8002698:	645a      	str	r2, [r3, #68]	; 0x44
 800269a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800269c:	f003 0310 	and.w	r3, r3, #16
 80026a0:	9300      	str	r3, [sp, #0]
 80026a2:	9b00      	ldr	r3, [sp, #0]
  
    /**USART1 GPIO Configuration    
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 80026a4:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 80026a8:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80026aa:	2302      	movs	r3, #2
 80026ac:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80026ae:	2301      	movs	r3, #1
 80026b0:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80026b2:	2303      	movs	r3, #3
 80026b4:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80026b6:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 80026b8:	2307      	movs	r3, #7
 80026ba:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80026bc:	f7fd fe9e 	bl	80003fc <HAL_GPIO_Init>

  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 80026c0:	b007      	add	sp, #28
 80026c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80026c6:	bf00      	nop
 80026c8:	40011000 	.word	0x40011000
 80026cc:	40023800 	.word	0x40023800
 80026d0:	40020000 	.word	0x40020000

080026d4 <__libc_init_array>:
 80026d4:	b570      	push	{r4, r5, r6, lr}
 80026d6:	4b0e      	ldr	r3, [pc, #56]	; (8002710 <__libc_init_array+0x3c>)
 80026d8:	4c0e      	ldr	r4, [pc, #56]	; (8002714 <__libc_init_array+0x40>)
 80026da:	1ae4      	subs	r4, r4, r3
 80026dc:	10a4      	asrs	r4, r4, #2
 80026de:	2500      	movs	r5, #0
 80026e0:	461e      	mov	r6, r3
 80026e2:	42a5      	cmp	r5, r4
 80026e4:	d004      	beq.n	80026f0 <__libc_init_array+0x1c>
 80026e6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80026ea:	4798      	blx	r3
 80026ec:	3501      	adds	r5, #1
 80026ee:	e7f8      	b.n	80026e2 <__libc_init_array+0xe>
 80026f0:	f000 f816 	bl	8002720 <_init>
 80026f4:	4c08      	ldr	r4, [pc, #32]	; (8002718 <__libc_init_array+0x44>)
 80026f6:	4b09      	ldr	r3, [pc, #36]	; (800271c <__libc_init_array+0x48>)
 80026f8:	1ae4      	subs	r4, r4, r3
 80026fa:	10a4      	asrs	r4, r4, #2
 80026fc:	2500      	movs	r5, #0
 80026fe:	461e      	mov	r6, r3
 8002700:	42a5      	cmp	r5, r4
 8002702:	d004      	beq.n	800270e <__libc_init_array+0x3a>
 8002704:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002708:	4798      	blx	r3
 800270a:	3501      	adds	r5, #1
 800270c:	e7f8      	b.n	8002700 <__libc_init_array+0x2c>
 800270e:	bd70      	pop	{r4, r5, r6, pc}
 8002710:	0800287c 	.word	0x0800287c
 8002714:	0800287c 	.word	0x0800287c
 8002718:	08002880 	.word	0x08002880
 800271c:	0800287c 	.word	0x0800287c

08002720 <_init>:
 8002720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002722:	bf00      	nop
 8002724:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002726:	bc08      	pop	{r3}
 8002728:	469e      	mov	lr, r3
 800272a:	4770      	bx	lr

0800272c <_fini>:
 800272c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800272e:	bf00      	nop
 8002730:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002732:	bc08      	pop	{r3}
 8002734:	469e      	mov	lr, r3
 8002736:	4770      	bx	lr
